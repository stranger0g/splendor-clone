Okay, here is the complete code for all the files in the specified structure, with most comments removed as requested.

**Folder Structure:**

```
splendor_project/
├── splendor_backend/
│   ├── main.py
│   ├── requirements.txt
│   ├── .env
│   └── game/
│       ├── __init__.py
│       ├── models.py
│       ├── data.py
│       ├── logic.py
│       ├── manager.py
│       ├── ai_service.py
│       └── exceptions.py
│
└── splendor_frontend/
    ├── index.html
    ├── style.css
    └── script.js
```

--- START OF FILE splendor_frontend/script.js ---
```javascript
document.addEventListener('DOMContentLoaded', () => {

    const API_BASE_URL = 'http://localhost:8080';
    const WS_BASE_URL = 'ws://localhost:8080';
    const AVAILABLE_AI_MODELS = {
        "gemini-1.5-flash": "Gemini 1.5 Flash",
        "gemini-1.0-pro": "Gemini 1.0 Pro",
    };
    const DEFAULT_AI_MODEL_ID = "gemini-1.5-flash";

    const setupJoinScreen = document.getElementById('setup-join-screen');
    const initialOptionsDiv = document.getElementById('initial-options');
    const createGameOptionsDiv = document.getElementById('create-game-options');
    const waitingLobbyDiv = document.getElementById('waiting-lobby');
    const playerNameInput = document.getElementById('player-name-input');
    const createGameBtn = document.getElementById('create-game-btn');
    const gameCodeInput = document.getElementById('game-code-input');
    const joinGameBtn = document.getElementById('join-game-btn');
    const playerCountCreateSelect = document.getElementById('player-count-create');
    const playerConfigsArea = document.getElementById('player-configs-area');
    const simulationDelayInput = document.getElementById('simulation-delay-input');
    const confirmCreateGameBtn = document.getElementById('confirm-create-game-btn');
    const cancelCreateGameBtn = document.getElementById('cancel-create-game-btn');
    const displayGameCode = document.getElementById('display-game-code');
    const copyCodeBtn = document.getElementById('copy-code-btn');
    const lobbyStatus = document.getElementById('lobby-status');
    const lobbyPlayerList = document.getElementById('lobby-player-list');
    const startGameBtn = document.getElementById('start-game-btn');
    const connectionStatus = document.getElementById('connection-status');
    const lobbyError = document.getElementById('lobby-error');

    const gameContainer = document.getElementById('game-container');
    const noblesContainer = document.querySelector('#nobles-area .nobles-container');
    const timerDisplay = document.getElementById('timer-display');
    const logMessagesDiv = document.getElementById('log-messages');
    const passTurnBtn = document.getElementById('pass-turn-btn');
    const serverMessage = document.getElementById('server-message');
    const gemBankContainer = document.getElementById('gem-bank');
    const selectionInfoDiv = document.getElementById('selection-info');
    const selectedGemsDisplay = document.getElementById('selected-gems-display');
    const selectedCardDisplay = document.getElementById('selected-card-display');
    const dynamicActionButtonsContainer = document.getElementById('dynamic-action-buttons');
    const deckCounts = { 1: document.getElementById('deck-1-count'), 2: document.getElementById('deck-2-count'), 3: document.getElementById('deck-3-count') };
    const visibleCardsContainers = { 1: document.getElementById('visible-cards-1'), 2: document.getElementById('visible-cards-2'), 3: document.getElementById('visible-cards-3') };
    const deckElements = { 1: document.getElementById('deck-1'), 2: document.getElementById('deck-2'), 3: document.getElementById('deck-3') };
    const playersAreaContainer = document.getElementById('players-area');

    const returnGemsOverlay = document.getElementById('return-gems-overlay');
    const returnGemsCountSpan = document.getElementById('return-gems-count');
    const returnGemsNeededSpan = document.getElementById('return-gems-needed');
    const returnGemsPlayerDisplay = document.getElementById('return-gems-player-display');
    const returnGemsSelectionDisplay = document.getElementById('return-gems-selection-display');
    const confirmReturnGemsBtn = document.getElementById('confirm-return-gems-btn');
    const returnGemsError = document.getElementById('return-gems-error');
    const gameOverOverlay = document.getElementById('game-over-overlay');
    const finalScoresDiv = document.getElementById('final-scores');
    const lobbyReturnBtn = document.getElementById('lobby-return-btn');
    const nobleChoiceOverlay = document.getElementById('noble-choice-overlay');
    const nobleChoiceOptionsContainer = document.getElementById('noble-choice-options');
    const nobleChoiceError = document.getElementById('noble-choice-error');

    let currentGameState = null;
    let webSocket = null;
    let myPlayerId = null;
    let currentGameCode = null;
    let isMyTurn = false;
    let isGameStarted = false;
    let isGameOver = false;
    let selectedGemTypes = [];
    let selectedCard = null;
    let currentAction = null;
    let returnGemsSelection = [];

    const GEM_TYPES = ['white', 'blue', 'green', 'red', 'black'];
    const GOLD = 'gold';
    const MAX_GEMS_PLAYER = 10;
    const MAX_RESERVED_CARDS = 3;
    const PLAYER_COLORS = ['player-color-1', 'player-color-2', 'player-color-3', 'player-color-4'];
    const MIN_GEMS_FOR_TAKE_TWO_CLIENT = 4;

    function showScreen(screenId) {
        [setupJoinScreen, gameContainer].forEach(screen => {
            const isActive = screen.id === screenId;
            screen.classList.toggle('hidden', !isActive);
            screen.classList.toggle('active', isActive);
        });
        if (screenId !== 'gameOverOverlay' && gameOverOverlay && !isGameOver) {
             gameOverOverlay.classList.add('hidden');
         }
        document.body.style.alignItems = (screenId === 'game-container' || screenId === 'gameOverOverlay') ? 'flex-start' : 'center';
         hideOverlays(true);
    }

    function resetLobbyState() {
        initialOptionsDiv.classList.remove('hidden');
        createGameOptionsDiv.classList.add('hidden');
        waitingLobbyDiv.classList.add('hidden');
        lobbyError.textContent = '';
        gameCodeInput.value = '';
        updateConnectionStatus("");
    }

    function resetGameClientState() {
        currentGameState = null;
        myPlayerId = null;
        currentGameCode = null;
        isMyTurn = false;
        isGameStarted = false;
        isGameOver = false;
        clearActionState();
        noblesContainer.innerHTML = '';
        gemBankContainer.innerHTML = '';
        visibleCardsContainers[1].innerHTML = '';
        visibleCardsContainers[2].innerHTML = '';
        visibleCardsContainers[3].innerHTML = '';
        playersAreaContainer.innerHTML = '';
        logMessagesDiv.innerHTML = '';
        serverMessage.textContent = '';
        timerDisplay.textContent = '--:--';
        hideOverlays();
    }

    function updateConnectionStatus(message, isError = false) {
        connectionStatus.textContent = message;
        connectionStatus.style.color = isError ? 'var(--text-error)' : 'var(--text-success)';
    }

    function updateLobbyError(message) {
        lobbyError.textContent = message;
    }

    function updateLobbyUI(state) {
        if (!state || !state.game_settings) {
            console.warn("Update lobby UI skip: incomplete state:", state);
            return;
        }
        displayGameCode.textContent = currentGameCode || 'N/A';
        lobbyPlayerList.innerHTML = '';
        const players = state.players || [];
        players.forEach(player => {
            const li = document.createElement('li');
            li.textContent = `${player.name || `Player ${player.id + 1}`}`;
            if (player.id === myPlayerId) {
                li.classList.add('player-self');
                li.textContent += ' (You)';
            }
            const typeSpan = document.createElement('span');
            typeSpan.classList.add('player-type-indicator');
            if (player.type === 'ai') {
                 const modelName = AVAILABLE_AI_MODELS[player.ai_model] || player.ai_model || 'Default';
                 typeSpan.textContent = `[AI - ${modelName}]`;
            } else {
                typeSpan.textContent = player.is_connected ? '(Connected)' : '(Waiting...)';
                typeSpan.style.color = player.is_connected ? 'var(--text-success)' : 'var(--text-tertiary)';
            }
            li.appendChild(typeSpan);
            lobbyPlayerList.appendChild(li);
        });
        const totalPlayers = state.game_settings.playerCount;
        const humanPlayers = players.filter(p => p.type === 'human');
        const allHumansConnected = humanPlayers.every(p => p.is_connected);
        const canStart = myPlayerId === state.creator_player_id && players.length === totalPlayers && allHumansConnected && !state.is_started;
        startGameBtn.classList.toggle('hidden', !canStart);
        if (myPlayerId === state.creator_player_id && !state.is_started) {
            if(canStart) {
                lobbyStatus.textContent = "All players connected. Ready to start!";
            } else {
                const connectedCount = humanPlayers.filter(p => p.is_connected).length;
                const neededCount = humanPlayers.length;
                 const waitingCount = neededCount - connectedCount;
                 if (waitingCount > 0) {
                     lobbyStatus.textContent = `Waiting for ${waitingCount} more human player(s)...`;
                 } else {
                      lobbyStatus.textContent = "Waiting for players...";
                 }
            }
        } else if (!state.is_started) {
             const creatorName = state.players?.[state.creator_player_id]?.name || 'Creator';
             lobbyStatus.textContent = `Waiting for ${creatorName} to start the game...`;
        } else {
             lobbyStatus.textContent = `Game in progress...`;
        }
    }

    function setupPlayerConfigurationInputs(playerCount) {
        playerConfigsArea.innerHTML = '';
        const myName = playerNameInput.value.trim() || 'Player 1';
        for (let i = 0; i < playerCount; i++) {
            const entryDiv = document.createElement('div'); entryDiv.classList.add('player-config-entry'); entryDiv.id = `player-config-${i}`;
            const label = document.createElement('span'); label.classList.add('player-config-label'); label.textContent = `P${i + 1}:`;
            const nameDisplay = document.createElement('span'); nameDisplay.classList.add('player-config-name'); nameDisplay.textContent = (i === 0) ? `${myName} (You)` : `Player ${i + 1}`;
            const typeSelect = document.createElement('select'); typeSelect.classList.add('player-type-select'); typeSelect.id = `player-type-${i}`; typeSelect.innerHTML = `<option value="human">Human</option><option value="ai">AI</option>`;
            const modelSelect = document.createElement('select'); modelSelect.classList.add('player-model-select', 'hidden'); modelSelect.id = `player-model-${i}`; modelSelect.disabled = true;
            for (const [modelId, modelName] of Object.entries(AVAILABLE_AI_MODELS)) { const option = document.createElement('option'); option.value = modelId; option.textContent = modelName; if(modelId === DEFAULT_AI_MODEL_ID) option.selected = true; modelSelect.appendChild(option); }
            if (i === 0) { typeSelect.value = 'human'; typeSelect.disabled = true; }
            typeSelect.addEventListener('change', (event) => { const isAI = event.target.value === 'ai'; modelSelect.classList.toggle('hidden', !isAI); modelSelect.disabled = !isAI; });
            entryDiv.appendChild(label); entryDiv.appendChild(nameDisplay); entryDiv.appendChild(typeSelect); entryDiv.appendChild(modelSelect); playerConfigsArea.appendChild(entryDiv);
        }
    }

     createGameBtn.addEventListener('click', () => { const playerName = playerNameInput.value.trim(); if (!playerName) { updateLobbyError("Please enter your name."); return; } initialOptionsDiv.classList.add('hidden'); createGameOptionsDiv.classList.remove('hidden'); updateLobbyError(''); setupPlayerConfigurationInputs(parseInt(playerCountCreateSelect.value, 10)); });
     playerCountCreateSelect.addEventListener('change', () => { setupPlayerConfigurationInputs(parseInt(playerCountCreateSelect.value, 10)); });
     cancelCreateGameBtn.addEventListener('click', resetLobbyState);
     confirmCreateGameBtn.addEventListener('click', async () => {
         const playerCount = parseInt(playerCountCreateSelect.value, 10); const playerConfigs = []; let hasError = false;
         for (let i = 0; i < playerCount; i++) {
             const name = (i === 0) ? (playerNameInput.value.trim() || `Player ${i+1}`) : `Player ${i+1}`; const typeSelect = document.getElementById(`player-type-${i}`); const modelSelect = document.getElementById(`player-model-${i}`); const type = typeSelect.value; let ai_model = null;
             if (type === 'ai') { ai_model = modelSelect.value; if (!ai_model || !AVAILABLE_AI_MODELS[ai_model]) { updateLobbyError(`Invalid AI model selected for Player ${i + 1}.`); hasError = true; break; } }
             playerConfigs.push({ name, type, ai_model });
         }
         if (hasError) { return; }
         const isSimulation = playerConfigs.every(p => p.type === 'ai'); const simulationDelay = parseInt(simulationDelayInput.value, 10) || 200;
         updateLobbyError(''); confirmCreateGameBtn.disabled = true;
         try {
             console.log("Sending Create Request:", { player_configs: playerConfigs, is_simulation: isSimulation, simulation_delay_ms: simulationDelay });
             const response = await fetch(`${API_BASE_URL}/games/create`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ player_configs: playerConfigs, is_simulation: isSimulation, simulation_delay_ms: simulationDelay }) });
             if (!response.ok) { const errorData = await response.json().catch(() => ({ detail: `Failed to create game (HTTP ${response.status})`})); throw new Error(errorData.detail); }
             const data = await response.json(); currentGameCode = data.game_code; myPlayerId = data.player_id; createGameOptionsDiv.classList.add('hidden'); waitingLobbyDiv.classList.remove('hidden'); displayGameCode.textContent = currentGameCode; lobbyStatus.textContent = 'Game created! Waiting for connection...'; lobbyPlayerList.innerHTML = `<li>${playerConfigs[0].name} (You) (Creator) (Waiting...)</li>`; connectWebSocket();
         } catch (error) { console.error("Error creating game:", error); updateLobbyError(error.message || "Could not connect to server."); confirmCreateGameBtn.disabled = false; }
          finally { confirmCreateGameBtn.disabled = false; }
     });
     joinGameBtn.addEventListener('click', async () => { const playerName = playerNameInput.value.trim(); const gameCode = gameCodeInput.value.trim().toUpperCase(); if (!playerName) { updateLobbyError("Please enter your name."); return; } if (!gameCode) { updateLobbyError("Please enter a game code."); return; } updateLobbyError(''); joinGameBtn.disabled = true; try { const response = await fetch(`${API_BASE_URL}/games/join/${gameCode}?player_name=${encodeURIComponent(playerName)}`); if (!response.ok) { const errorData = await response.json().catch(() => ({ detail: `Failed to join game (HTTP ${response.status})`})); throw new Error(errorData.detail); } const data = await response.json(); currentGameCode = gameCode; myPlayerId = data.player_id; initialOptionsDiv.classList.add('hidden'); waitingLobbyDiv.classList.remove('hidden'); updateLobbyUI(data.game_state); lobbyStatus.textContent = 'Joined lobby! Waiting for connection...'; connectWebSocket(); } catch (error) { console.error("Error joining game:", error); updateLobbyError(error.message || "Could not join game or connect to server."); joinGameBtn.disabled = false; } finally { joinGameBtn.disabled = false; } });
     startGameBtn.addEventListener('click', () => { if (webSocket && webSocket.readyState === WebSocket.OPEN) { sendWebSocketMessage({ type: "START_GAME" }); startGameBtn.classList.add('hidden'); } else { updateLobbyError("Not connected to server."); } });
     copyCodeBtn.addEventListener('click', () => { if(!currentGameCode) return; navigator.clipboard.writeText(currentGameCode) .then(() => { copyCodeBtn.textContent = '✅'; setTimeout(() => { copyCodeBtn.textContent = '📋'; }, 1500); }) .catch(err => { console.error('Failed to copy game code: ', err); updateLobbyError('Failed to copy code.'); }); });
     lobbyReturnBtn.addEventListener('click', () => { disconnectWebSocket(); resetGameClientState(); resetLobbyState(); showScreen('setup-join-screen'); });


    function connectWebSocket() { if (!currentGameCode || myPlayerId === null) { console.error("WS Connect Fail: Missing game/player ID."); updateConnectionStatus("Error: Missing details.", true); resetLobbyState(); return; } if (webSocket && webSocket.readyState === WebSocket.OPEN) { console.log("WS already open."); return; } const wsUrl = `${WS_BASE_URL}/ws/${currentGameCode}/${myPlayerId}`; console.log("Connecting WS:", wsUrl); webSocket = new WebSocket(wsUrl); updateConnectionStatus("Connecting...", false); webSocket.onopen = () => { console.log("WS connected:", wsUrl); updateConnectionStatus("Connected", false); }; webSocket.onmessage = (event) => { try { const message = JSON.parse(event.data); console.debug("WS recv:", message.type); handleWebSocketMessage(message); } catch (error) { console.error("WS parse error:", error, event.data); } }; webSocket.onerror = (error) => { console.error("WS error:", error); updateConnectionStatus("Connection error!", true); if(isGameStarted && !isGameOver) { updateServerError("Connection error."); } else if (!isGameStarted) { updateLobbyError("Connection error."); } updateClickableState(); }; webSocket.onclose = (event) => { console.log("WS disconnected:", event.code, event.reason); const wasConnected = connectionStatus.textContent === "Connected"; updateConnectionStatus(`Disconnected: ${event.reason || `Code ${event.code}`}`, true); webSocket = null; if (isGameStarted && !isGameOver && wasConnected) { updateServerError("Disconnected."); updateClickableState(); } else if (!isGameStarted && wasConnected) { updateLobbyError("Disconnected."); } }; }
    function disconnectWebSocket() { if (webSocket) { console.log("Closing WS."); webSocket.onclose = null; webSocket.onerror = null; webSocket.close(1000, "Client disconnect"); webSocket = null; updateConnectionStatus("Disconnected", true); } }
    function sendWebSocketMessage(message) { if (webSocket && webSocket.readyState === WebSocket.OPEN) { try { console.debug("WS send:", message); webSocket.send(JSON.stringify(message)); } catch (error) { console.error("WS send error:", error); updateConnectionStatus("Send Error!", true); updateServerError("Send failed."); } } else { console.error("WS not open."); updateConnectionStatus("Not connected!", true); if (isGameStarted) { updateServerError("Not connected."); } else { updateLobbyError("Not connected."); } } }

    function handleWebSocketMessage(message) {
        if (!message || !message.type) return;
        switch (message.type) {
            case "GAME_STATE_UPDATE":
                const newState = message.payload; const gameJustStarted = !isGameStarted && newState?.is_started;
                currentGameState = newState; isGameStarted = currentGameState?.is_started || false; isGameOver = currentGameState?.game_truly_finished || false;
                isMyTurn = currentGameState?.current_player_index === myPlayerId && !currentGameState?.pending_action && !isGameOver;
                if (isGameStarted && !isGameOver) { showScreen('game-container'); updateGameUI(currentGameState); handlePendingActions(currentGameState); if (gameJustStarted) { updateGameLogClientOnly("Game Started!"); } }
                else if (!isGameStarted && !isGameOver) { showScreen('setup-join-screen'); updateLobbyUI(currentGameState); }
                break;
            case "PLAYER_JOINED": console.log(`Player ${message.payload.player_id} (${message.payload.player_name}) joined.`); break;
            case "PLAYER_LEFT": console.log(`Player ${message.payload.player_id} (${message.payload.player_name}) left.`); if (isGameStarted && !isGameOver) { updateGameLogClientOnly(`${message.payload.player_name} disconnected.`); } break;
            case "ERROR":
                console.error("Server Error:", message.payload.message); const errorMsg = message.payload.message || "Unknown error.";
                if (!isGameStarted) { updateLobbyError(errorMsg); } else if (isGameOver) { /* Ignore */ } else if (!nobleChoiceOverlay.classList.contains('hidden')) { nobleChoiceError.textContent = errorMsg; } else if (!returnGemsOverlay.classList.contains('hidden')) { returnGemsError.textContent = errorMsg; } else { updateServerError(errorMsg); }
                clearActionState(); updateClickableState();
                break;
            case "GAME_OVER":
                console.log("Game Over received:", message.payload); currentGameState = message.payload; isGameOver = true; isGameStarted = false; isMyTurn = false;
                renderGameOver(message.payload); hideOverlays(true); gameOverOverlay.classList.remove('hidden');
                updateClickableState();
                break;
            default: console.log("Unknown WS msg type:", message.type);
        }
    }
    function handlePendingActions(state) { if (!state || isGameOver) return; const pending = state.pending_action; const isMyPendingAction = pending && pending.player_id === myPlayerId; if (!isMyPendingAction) { hideOverlays(); } else { if (pending.type === "RETURN_GEMS") { if (returnGemsOverlay.classList.contains('hidden')) { showReturnGemsOverlay(state.players[myPlayerId], pending.current_total, pending.count_needed, pending.non_gold_owned); } } else if (pending.type === "CHOOSE_NOBLE") { if (nobleChoiceOverlay.classList.contains('hidden')) { const eligibleNoblesData = pending.eligible_nobles || []; showNobleChoiceOverlay(state.players[myPlayerId], eligibleNoblesData); } } else { console.warn("Unknown pending action:", pending.type); hideOverlays(); } } updateClickableState(); }

    function updateGameUI(state) { if (!state || !state.players) { console.error("Invalid game state for UI update:", state); updateServerError("Error: Invalid game state."); return; } isMyTurn = state.current_player_index === myPlayerId && !state.pending_action && !state.game_truly_finished; if (!serverMessage.textContent?.includes("Disconnected")) { updateServerError(""); } renderBank(state.bank); renderCards(state.visible_cards, state.decks); renderNobles(state.available_nobles); renderPlayers(state.players); highlightActivePlayer(state.current_player_index); updateGameLog(state.game_history_log); passTurnBtn.classList.toggle('hidden', !isMyTurn || state.pending_action); if (state.is_game_over_condition_met && !state.game_truly_finished) { updateServerError("FINAL ROUND!"); } updateClickableState(); }
    function renderBank(bankData) { gemBankContainer.innerHTML = ''; if (!bankData) return; [...GEM_TYPES, GOLD].forEach(gemType => { const count = bankData[gemType] ?? 0; const gemEl = createGemElement(gemType, count, true); gemEl.dataset.gemType = gemType; gemEl.title = `${count} ${gemType} available`; gemEl.addEventListener('click', handleGemClickWrapper); gemBankContainer.appendChild(gemEl); }); }
    function renderCards(visibleCardsData, decksData) { for (let level = 1; level <= 3; level++) { const container = visibleCardsContainers[level]; const cards = visibleCardsData?.[level] || []; container.innerHTML = ''; for (let i = 0; i < 4; i++) { const cardData = cards[i]; const cardEl = createCardElement(cardData, level, i); if (cardData) { cardEl.dataset.cardId = cardData.id; cardEl.dataset.level = level; cardEl.addEventListener('click', handleVisibleCardClickWrapper); } container.appendChild(cardEl); } const deckCount = decksData?.[level]?.length ?? 0; if (deckCounts[level] && deckElements[level]) { deckCounts[level].textContent = deckCount; deckElements[level].classList.toggle('empty', deckCount === 0); deckElements[level].title = `${deckCount} cards left in Level ${level} deck`; deckElements[level].dataset.level = level; deckElements[level].removeEventListener('click', handleDeckClick); deckElements[level].addEventListener('click', handleDeckClick); } } }
    function renderNobles(noblesData) { noblesContainer.innerHTML = ''; if (!noblesData) return; noblesData.forEach(nobleData => { noblesContainer.appendChild(createNobleElement(nobleData)); }); }
    function renderPlayers(playersData) { playersAreaContainer.innerHTML = ''; if (!playersData) return; const assignedColors = {}; playersData.forEach((playerData, index) => { assignedColors[playerData.id] = PLAYER_COLORS[index % PLAYER_COLORS.length]; }); playersData.forEach(playerData => { const playerEl = createPlayerAreaElement(playerData, assignedColors[playerData.id]); if (playerData.id === myPlayerId) { playerEl.classList.add('player-self-area'); } playerEl.querySelectorAll('.reserved-card-small').forEach(rc => { rc.addEventListener('click', handleReservedCardClickWrapper); }); playersAreaContainer.appendChild(playerEl); }); }
    function highlightActivePlayer(activePlayerIndex) { document.querySelectorAll('.player-area.active-player').forEach(el => el.classList.remove('active-player')); if (activePlayerIndex !== null && !isGameOver) { const activePlayerEl = document.getElementById(`player-area-${activePlayerIndex}`); if (activePlayerEl) { activePlayerEl.classList.add('active-player'); } } }
    function updateGameLog(historyLog) { logMessagesDiv.innerHTML = ''; if (!historyLog) return; historyLog.forEach(logEntry => { const friendlyMessage = formatLogEntry(logEntry); const p = document.createElement('p'); p.textContent = friendlyMessage; logMessagesDiv.appendChild(p); }); logMessagesDiv.scrollTop = logMessagesDiv.scrollHeight; }
    function updateGameLogClientOnly(message) { const p = document.createElement('p'); const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' }); p.textContent = `${timestamp} [SYSTEM] ${message}`; p.style.fontStyle = 'italic'; p.style.color = 'var(--text-tertiary)'; logMessagesDiv.appendChild(p); logMessagesDiv.scrollTop = logMessagesDiv.scrollHeight; }
    function updateServerError(message) { serverMessage.textContent = message; serverMessage.style.color = message ? 'var(--text-error)' : 'inherit'; }
    function formatLogEntry(logEntry) { const { turn, playerIndex, playerName, playerType, actionType, details } = logEntry; let detailsStr = ''; try { if (actionType === 'TAKE_GEMS') detailsStr = `Took ${details.gems.join(', ')}`; else if (actionType === 'PURCHASE_CARD') detailsStr = `Purchased ${details.color} L${details.level} (${details.cardId})${details.source === 'reserved' ? ' (reserve)' : ''}`; else if (actionType === 'RESERVE_CARD') detailsStr = `Reserved ${details.source === 'deck' ? `L${details.level} deck card` : `L${details.level} ${details.color} card (${details.cardId})`}${details.gotGold ? ' + Gold' : ''}`; else if (actionType === 'RETURN_GEMS') detailsStr = `Returned ${Object.entries(details.returnedGems).map(([g,c])=>`${c} ${g}`).join(', ')}`; else if (actionType === 'NOBLE_VISIT') detailsStr = `Attracted Noble ${details.nobleId} (${details.vp} VP)`; else if (actionType === 'PASS_TURN') detailsStr = 'Passed turn'; else if (actionType === 'GAME_STARTED') detailsStr = 'Game Started by creator'; else if (actionType === 'GAME_CREATE') detailsStr = 'Game Created'; else if (actionType === 'PLAYER_DISCONNECTED') detailsStr = 'Disconnected'; else if (actionType === 'PENDING_GEM_RETURN') detailsStr = `Must return ${details.count} gems`; else if (actionType === 'PENDING_NOBLE_CHOICE') detailsStr = `Must choose 1 of ${details.count} nobles`; else if (actionType === 'GAME_END_TRIGGERED') detailsStr = `Triggered final round (Score: ${details.score})`; else if (actionType === 'FINAL_TURN_COMPLETED') detailsStr = 'Completed final turn'; else if (actionType === 'GAME_WINNER_CALCULATED') detailsStr = `Game ended. Winner(s): P${details.winners?.join(', P') ?? 'N/A'}`; else if (actionType.startsWith('FALLBACK_')) detailsStr = `Used fallback: ${actionType.substring(9)}`; else if (actionType === 'AI_FATAL_ERROR' || actionType === 'AI_FATAL_ERROR_PENDING') detailsStr = 'AI encountered critical error'; else detailsStr = JSON.stringify(details); } catch { detailsStr = '...'; } return `[T${turn}] P${playerIndex} (${playerName}${playerType === 'ai' ? '-AI' : ''}): ${actionType} - ${detailsStr}`; }

    function createGemElement(type, count, isBank) { const gemEl = document.createElement('div'); gemEl.classList.add('gem', `gem-${type}`); if (isBank) { const countEl = document.createElement('span'); countEl.classList.add('gem-count'); countEl.textContent = count; gemEl.appendChild(countEl); } else { gemEl.classList.add('small-gems'); gemEl.style.cursor = 'default'; } return gemEl; }
    function createCardElement(cardData, level, index = -1) { const cardEl = document.createElement('div'); cardEl.classList.add('card'); cardEl.dataset.level = level; if (index !== -1) cardEl.dataset.index = index; if (!cardData) { cardEl.classList.add('empty-slot'); cardEl.textContent = 'Empty'; return cardEl; } cardEl.classList.add(`card-border-${cardData.color}`); cardEl.dataset.cardId = cardData.id; cardEl.title = formatCardCostForTitle(cardData); const topArea = document.createElement('div'); topArea.classList.add('card-top-area'); const vpSpan = document.createElement('span'); vpSpan.classList.add('card-vp'); vpSpan.textContent = cardData.vp > 0 ? cardData.vp : ''; const gemBonus = document.createElement('div'); gemBonus.classList.add('card-gem-bonus', `gem-${cardData.color}`); topArea.appendChild(vpSpan); topArea.appendChild(gemBonus); const centerArea = document.createElement('div'); centerArea.classList.add('card-center-area'); centerArea.dataset.level = level; const costArea = document.createElement('div'); costArea.classList.add('card-cost-area'); if (cardData.cost) { GEM_TYPES.forEach(gemType => { const cost = cardData.cost[gemType] ?? 0; if (cost > 0) { const costItem = document.createElement('div'); costItem.classList.add('cost-item'); const costDot = document.createElement('span'); costDot.classList.add('cost-dot', `gem-${gemType}`); costItem.appendChild(costDot); costItem.appendChild(document.createTextNode(cost)); costArea.appendChild(costItem); } }); } cardEl.appendChild(topArea); cardEl.appendChild(centerArea); cardEl.appendChild(costArea); return cardEl; }
    function createSmallReservedCardElement(cardData) { const cardEl = document.createElement('div'); cardEl.classList.add('reserved-card-small', `card-border-${cardData.color}`); cardEl.dataset.cardId = cardData.id; cardEl.title = formatCardCostForTitle(cardData); const topArea = document.createElement('div'); topArea.classList.add('card-top-area'); const vpSpan = document.createElement('span'); vpSpan.classList.add('card-vp'); vpSpan.textContent = cardData.vp > 0 ? cardData.vp : ''; const gemBonus = document.createElement('div'); gemBonus.classList.add('card-gem-bonus', `gem-${cardData.color}`); topArea.appendChild(vpSpan); topArea.appendChild(gemBonus); const costArea = document.createElement('div'); costArea.classList.add('card-cost-area'); if (cardData.cost) { GEM_TYPES.forEach(gemType => { const cost = cardData.cost[gemType] ?? 0; if (cost > 0) { const costItem = document.createElement('div'); costItem.classList.add('cost-item'); const costDot = document.createElement('span'); costDot.classList.add('cost-dot', `gem-${gemType}`); costItem.appendChild(costDot); costItem.appendChild(document.createTextNode(cost)); costArea.appendChild(costItem); } }); } cardEl.appendChild(topArea); cardEl.appendChild(costArea); return cardEl; }
    function createNobleElement(nobleData) { const nobleEl = document.createElement('div'); nobleEl.classList.add('noble'); nobleEl.dataset.nobleId = nobleData.id; const reqString = GEM_TYPES .map(type => ({ type, count: nobleData.requirements?.[type] ?? 0 })) .filter(item => item.count > 0) .map(item => `${item.count} ${item.type}`) .join(', '); nobleEl.title = `${nobleData.vp} VP - Requires: ${reqString}`; const vpSpan = document.createElement('span'); vpSpan.classList.add('noble-vp'); vpSpan.textContent = nobleData.vp; const reqsDiv = document.createElement('div'); reqsDiv.classList.add('noble-requirements'); if(nobleData.requirements) { GEM_TYPES.forEach(gemType => { const req = nobleData.requirements[gemType] ?? 0; if (req > 0) { const reqItem = document.createElement('div'); reqItem.classList.add('req-item'); reqItem.textContent = req; const reqGem = document.createElement('span'); reqGem.classList.add('req-gem', `gem-${gemType}`); reqItem.appendChild(reqGem); reqsDiv.appendChild(reqItem); } }); } nobleEl.appendChild(vpSpan); nobleEl.appendChild(reqsDiv); return nobleEl; }
    function createPlayerAreaElement(player, playerColorClass) { const playerDiv = document.createElement('div'); playerDiv.classList.add('player-area'); if (playerColorClass) playerDiv.classList.add(playerColorClass); playerDiv.id = `player-area-${player.id}`; const header = document.createElement('div'); header.classList.add('player-header'); const nameSpan = document.createElement('span'); nameSpan.classList.add('player-name'); nameSpan.textContent = player.name; const scoreSpan = document.createElement('span'); scoreSpan.classList.add('player-score'); scoreSpan.textContent = `VP: ${player.score ?? 0}`; scoreSpan.title = `${player.score ?? 0} Victory Points`; header.appendChild(nameSpan); header.appendChild(scoreSpan); if (player.type === 'ai') { const badge = document.createElement('span'); badge.classList.add('ai-badge'); badge.textContent = `AI (${AVAILABLE_AI_MODELS[player.ai_model] || player.ai_model || 'Default'})`; header.appendChild(badge); } const resourcesDiv = document.createElement('div'); resourcesDiv.classList.add('player-resources'); const gemsHeader = document.createElement('h4'); gemsHeader.textContent = 'Tokens'; resourcesDiv.appendChild(gemsHeader); const gemsContainer = document.createElement('div'); gemsContainer.classList.add('gems-container', 'small-gems'); let totalNonGoldGems = 0; let totalGems = 0; if (player.gems) { GEM_TYPES.forEach(gemType => { const count = player.gems[gemType] ?? 0; totalNonGoldGems += count; if (count > 0) { gemsContainer.appendChild(createGemElement(gemType, count, true)); } }); const goldCount = player.gems[GOLD] ?? 0; if (goldCount > 0) { gemsContainer.appendChild(createGemElement(GOLD, goldCount, true)); } totalGems = totalNonGoldGems + goldCount; } resourcesDiv.appendChild(gemsContainer); const totalGemsSpan = document.createElement('span'); totalGemsSpan.classList.add('total-gems-indicator'); totalGemsSpan.textContent = `Total: ${totalGems}/${MAX_GEMS_PLAYER}`; totalGemsSpan.title = `${totalNonGoldGems} regular + ${player.gems?.[GOLD] ?? 0} gold = ${totalGems} total`; if (totalGems > MAX_GEMS_PLAYER) { totalGemsSpan.style.color = 'var(--text-error)'; totalGemsSpan.style.fontWeight = 'bold'; } resourcesDiv.appendChild(totalGemsSpan); const bonusHeader = document.createElement('h4'); bonusHeader.textContent = 'Bonuses'; resourcesDiv.appendChild(bonusHeader); const bonusContainer = document.createElement('div'); bonusContainer.classList.add('player-cards'); let hasBonuses = false; if(player.bonuses) { GEM_TYPES.forEach(gemType => { const count = player.bonuses[gemType] ?? 0; if (count > 0) { hasBonuses = true; const bonusEl = document.createElement('div'); bonusEl.classList.add('player-card-count', `gem-${gemType}`); bonusEl.textContent = count; bonusEl.title = `${count} ${gemType} bonus (discount)`; bonusContainer.appendChild(bonusEl); } }); } if (!hasBonuses) bonusContainer.innerHTML = '<span class="no-items">None</span>'; resourcesDiv.appendChild(bonusContainer); const reservedCards = player.reservedCards || []; const reservedHeader = document.createElement('h4'); reservedHeader.textContent = `Reserved (${reservedCards.length}/${MAX_RESERVED_CARDS})`; resourcesDiv.appendChild(reservedHeader); const reservedContainer = document.createElement('div'); reservedContainer.classList.add('reserved-cards-container'); if (reservedCards.length > 0) { reservedCards.forEach(cardData => { if(cardData) { const reservedCardEl = createSmallReservedCardElement(cardData); reservedContainer.appendChild(reservedCardEl); } }); } else { reservedContainer.innerHTML = '<span class="no-items">None reserved</span>'; reservedContainer.style.textAlign = 'center'; } resourcesDiv.appendChild(reservedContainer); const nobles = player.nobles || []; const noblesHeader = document.createElement('h4'); noblesHeader.textContent = `Nobles (${nobles.length})`; resourcesDiv.appendChild(noblesHeader); const playerNoblesContainer = document.createElement('div'); playerNoblesContainer.classList.add('nobles-container', 'player-nobles-display'); if (nobles.length > 0) { nobles.forEach(nobleData => { if(nobleData) { const nobleEl = createNobleElement(nobleData); nobleEl.style.transform = 'scale(0.8)'; playerNoblesContainer.appendChild(nobleEl); } }); } else { playerNoblesContainer.innerHTML = '<span class="no-items">None</span>'; playerNoblesContainer.style.textAlign = 'center'; } resourcesDiv.appendChild(playerNoblesContainer); playerDiv.appendChild(header); playerDiv.appendChild(resourcesDiv); return playerDiv; }
    function formatCardCostForTitle(cardData) { let title = `L${cardData.level} ${cardData.color} (${cardData.vp} VP)`; if (cardData.cost) { const costString = GEM_TYPES .map(type => ({ type, count: cardData.cost[type] ?? 0 })) .filter(item => item.count > 0) .map(item => `${item.count} ${item.type}`) .join(', '); title += `\nCost: ${costString || 'Free'}`; } else { title += '\nCost: Unknown'; } return title; }

    function handleGemClickWrapper(event) { const gemEl = event.currentTarget; if (!gemEl.classList.contains('interactive')) return; handleGemClick(gemEl.dataset.gemType, gemEl); }
    function handleVisibleCardClickWrapper(event) { const cardEl = event.currentTarget; if (!cardEl.classList.contains('interactive') || cardEl.classList.contains('empty-slot')) return; const cardId = cardEl.dataset.cardId; const level = parseInt(cardEl.dataset.level, 10); if (cardId && !isNaN(level)) { handleCardClick('visible', level, cardId, cardEl); } else { console.error("Visible card click error: Missing cardId or level", cardEl.dataset); } }
    function handleReservedCardClickWrapper(event) { const cardEl = event.currentTarget; const playerArea = cardEl.closest('.player-area'); if (!playerArea || isGameOver) return; const isClickableForAction = cardEl.classList.contains('interactive'); const cardId = cardEl.dataset.cardId; if (cardId) { handleReservedCardClick(cardId, cardEl, isClickableForAction); } else { console.error("Reserved card click error: Missing cardId", cardEl); } }
    function handleDeckClick(event) { const deckEl = event.currentTarget; if (!deckEl.classList.contains('interactive') || deckEl.classList.contains('empty')) return; const level = parseInt(deckEl.dataset.level, 10); if (!isNaN(level)) { handleCardClick('deck', level, `deck-${level}`, deckEl); } else { console.error("Deck click error: Missing level", deckEl.dataset); } }
    function handleGemClick(gemType, clickedGemEl) { if (gemType === GOLD) return; if (currentAction === 'SELECTING_CARD') { clearCardSelectionState(true); } currentAction = 'SELECTING_GEMS'; const isSelectedLogically = selectedGemTypes.includes(gemType); const currentCount = selectedGemTypes.length; const uniqueCount = new Set(selectedGemTypes).size; const bankCount = currentGameState?.bank?.[gemType] ?? 0; console.log(`Gem click: ${gemType}, selected: ${isSelectedLogically}, count: ${currentCount}, unique: ${uniqueCount}, bank: ${bankCount}`); if (!isSelectedLogically) { let canAdd = false; if (currentCount === 0 && bankCount >= 1) { canAdd = true; } else if (currentCount === 1) { const firstType = selectedGemTypes[0]; if (gemType !== firstType && bankCount >= 1) { canAdd = true; } } else if (currentCount === 2) { if (uniqueCount === 2 && !selectedGemTypes.includes(gemType) && bankCount >= 1) { canAdd = true; } } if (canAdd) { console.log(` -> Adding ${gemType}`); selectedGemTypes.push(gemType); clickedGemEl.classList.add('selected', 'preview-selection'); } else { console.log(` -> Cannot add ${gemType}`); clickedGemEl.style.animation = 'shake 0.5s'; setTimeout(() => { clickedGemEl.style.animation = ''; }, 500); } } else { if (currentCount === 1 && selectedGemTypes[0] === gemType && bankCount >= MIN_GEMS_FOR_TAKE_TWO_CLIENT) { console.log(` -> Completing Take 2 ${gemType}`); selectedGemTypes.push(gemType); document.querySelectorAll(`#gem-bank .gem[data-gem-type="${gemType}"]`).forEach(el => { if (!el.classList.contains('selected')) el.classList.add('selected', 'preview-selection'); }); } else { const indexToRemove = selectedGemTypes.indexOf(gemType); if (indexToRemove > -1) { if (currentCount === 2 && uniqueCount === 1 && selectedGemTypes[0] === gemType) { console.log(` -> Removing Take 2 pair ${gemType}`); selectedGemTypes = []; document.querySelectorAll(`#gem-bank .gem[data-gem-type="${gemType}"]`).forEach(el => el.classList.remove('selected', 'preview-selection')); } else { console.log(` -> Deselecting one ${gemType}`); selectedGemTypes.splice(indexToRemove, 1); clickedGemEl.classList.remove('selected', 'preview-selection'); if(currentCount === 3 && selectedGemTypes.length === 2) { document.querySelectorAll('#gem-bank .gem.selected').forEach(el => el.classList.remove('selected', 'preview-selection')); selectedGemTypes.forEach(type => { const elToSelect = document.querySelector(`#gem-bank .gem[data-gem-type="${type}"]:not(.selected)`); if (elToSelect) elToSelect.classList.add('selected', 'preview-selection'); else document.querySelector(`#gem-bank .gem[data-gem-type="${type}"]`)?.classList.add('selected', 'preview-selection'); }); } else if (selectedGemTypes.filter(g => g === gemType).length === 0) { document.querySelectorAll(`#gem-bank .gem[data-gem-type="${gemType}"]`).forEach(el => el.classList.remove('selected', 'preview-selection'));} } } else { console.warn("Selected gem not found?", gemType, selectedGemTypes); clickedGemEl.classList.remove('selected', 'preview-selection'); } } } if (selectedGemTypes.length === 0) { currentAction = null; } console.log("Selected Gems:", selectedGemTypes); renderSelectionInfo(); updateClickableState(); }
    function handleCardClick(type, level, id, element) { if (currentAction === 'SELECTING_GEMS') { clearGemSelectionState(true); } if (selectedCard && selectedCard.id === id) { clearCardSelectionState(true); currentAction = null; } else { clearCardSelectionState(true); currentAction = 'SELECTING_CARD'; selectedCard = { type, level, id, element }; element.classList.add('selected', 'preview-selection'); } renderSelectionInfo(); updateClickableState(); }
    function handleReservedCardClick(cardId, cardEl, isClickableForAction) { const playerArea = cardEl.closest('.player-area'); if (!playerArea) return; const ownerId = parseInt(playerArea.id.split('-')[2], 10); const cardData = currentGameState?.players?.[ownerId]?.reservedCards?.find(c => c.id === cardId); if (!cardData) { console.error("Reserved card data not found:", cardId); return; } if (isClickableForAction) { if (currentAction === 'SELECTING_GEMS') { clearGemSelectionState(true); } if (selectedCard && selectedCard.id === cardId) { clearCardSelectionState(true); currentAction = null; } else { clearCardSelectionState(true); currentAction = 'SELECTING_CARD'; selectedCard = { type: 'reserved', level: cardData.level, id: cardId, element: cardEl, ownerId: ownerId }; cardEl.classList.add('selected', 'preview-selection'); } } else { if (currentAction && ownerId !== myPlayerId) { clearActionState(); } return; } renderSelectionInfo(); updateClickableState(); }
    function confirmTakeGems() { if (!validateTakeGemsSelectionLocal() || !selectedGemTypes || selectedGemTypes.length === 0) { updateServerError("Invalid gem selection."); console.warn("Client validation failed take gems:", selectedGemTypes); return; } sendWebSocketMessage({ type: "TAKE_GEMS", payload: { gems: selectedGemTypes } }); clearActionState(); }
    function confirmReserveCard() { if (!selectedCard || (selectedCard.type !== 'visible' && selectedCard.type !== 'deck')) { updateServerError("No valid card/deck selected to reserve."); return; } const payload = { source: selectedCard.type }; if (selectedCard.type === 'visible') { payload.cardId = selectedCard.id; } else { payload.level = selectedCard.level; } sendWebSocketMessage({ type: "RESERVE_CARD", payload: payload }); clearActionState(); }
    function confirmPurchaseCard() { if (!selectedCard || (selectedCard.type !== 'visible' && selectedCard.type !== 'reserved')) { updateServerError("No valid card selected to purchase."); return; } sendWebSocketMessage({ type: "PURCHASE_CARD", payload: { source: selectedCard.type, cardId: selectedCard.id } }); clearActionState(); }
    passTurnBtn.addEventListener('click', () => { if (!isMyTurn) return; console.log("Sending PASS_TURN message"); sendWebSocketMessage({ type: "PASS_TURN" }); clearActionState(); passTurnBtn.classList.add('hidden'); });

     function renderSelectionInfo() { dynamicActionButtonsContainer.innerHTML = ''; const existingPreview = selectionInfoDiv.querySelector('.card-preview-container'); if (existingPreview) existingPreview.remove(); selectionInfoDiv.querySelectorAll('.selection-text').forEach(p => { p.style.display = 'block'; }); if (selectedCardDisplay) selectedCardDisplay.textContent = 'None'; if (selectedGemsDisplay) selectedGemsDisplay.textContent = 'None'; if (currentAction === 'SELECTING_GEMS' && selectedGemTypes.length > 0) { if (selectedGemsDisplay) { selectedGemsDisplay.innerHTML = ''; selectedGemTypes.forEach(type => { selectedGemsDisplay.appendChild(createGemElement(type, 1, false)); }); } if (validateTakeGemsSelectionLocal()) { const btn = document.createElement('button'); btn.textContent = 'Confirm Take Tokens'; btn.onclick = confirmTakeGems; btn.classList.add('action-possible'); dynamicActionButtonsContainer.appendChild(btn); } if (selectedCardDisplay) selectedCardDisplay.textContent = 'None'; } else if (currentAction === 'SELECTING_CARD' && selectedCard) { let cardData = getCardDataFromState(selectedCard.id); let cardText = 'Invalid Card Selection'; let isMyReservedCard = false; if (!cardData && selectedCard.type === 'deck') { cardData = getDeckCardPlaceholder(selectedCard.level); cardText = `Deck L${cardData.level}`; } else if (cardData) { cardText = `L${cardData.level} ${cardData.color}`; isMyReservedCard = selectedCard.type === 'reserved' && selectedCard.ownerId === myPlayerId; } if (cardData) { if (selectedCard.type === 'visible' || isMyReservedCard) { selectionInfoDiv.querySelectorAll('.selection-text').forEach(p => { p.style.display = 'none'; }); const previewContainer = document.createElement('div'); previewContainer.classList.add('card-preview-container'); const previewCardEl = createCardElement(cardData, cardData.level); previewCardEl.classList.add('card-preview'); const clonedPreview = previewCardEl.cloneNode(true); previewContainer.appendChild(clonedPreview); selectionInfoDiv.insertBefore(previewContainer, dynamicActionButtonsContainer); if (selectedCardDisplay) selectedCardDisplay.textContent = ''; } else { if (selectedCardDisplay) selectedCardDisplay.textContent = cardText; } if (selectedGemsDisplay) selectedGemsDisplay.textContent = 'None'; if (isMyTurn) { const player = currentGameState?.players?.[myPlayerId]; const canReserve = player && (player.reservedCards?.length ?? 0) < MAX_RESERVED_CARDS; const canAfford = player && cardData && cardData.cost ? canAffordCardLocal(player, cardData) : false; if ((selectedCard.type === 'visible' || isMyReservedCard) && cardData.id) { const purchaseBtn = document.createElement('button'); purchaseBtn.textContent = 'Purchase Card'; purchaseBtn.onclick = confirmPurchaseCard; purchaseBtn.disabled = !canAfford; if (canAfford) purchaseBtn.classList.add('action-possible'); else purchaseBtn.title = "Affordability check failed (client-side)"; dynamicActionButtonsContainer.appendChild(purchaseBtn); } if (selectedCard.type === 'visible' || selectedCard.type === 'deck') { const reserveBtn = document.createElement('button'); reserveBtn.textContent = 'Reserve Card'; reserveBtn.onclick = confirmReserveCard; const isDeckEmpty = selectedCard.type === 'deck' && (currentGameState?.decks?.[selectedCard.level]?.length ?? 0) === 0; const disableReserve = !canReserve || isDeckEmpty; reserveBtn.disabled = disableReserve; if (!disableReserve) reserveBtn.classList.add('action-possible'); if (!canReserve) reserveBtn.title = "Reservation limit reached"; if (isDeckEmpty) reserveBtn.title = `Level ${selectedCard.level} deck is empty`; dynamicActionButtonsContainer.appendChild(reserveBtn); } } } else { if (selectedCardDisplay) selectedCardDisplay.textContent = cardText; if (selectedGemsDisplay) selectedGemsDisplay.textContent = 'None'; } } else { if (selectedCardDisplay) selectedCardDisplay.textContent = 'None'; if (selectedGemsDisplay) selectedGemsDisplay.textContent = 'None'; } }
     function validateTakeGemsSelectionLocal() { const gems = selectedGemTypes; const count = gems.length; const uniqueCount = new Set(gems).size; const bank = currentGameState?.bank; if (!bank) return false; if (count === 3 && uniqueCount === 3) { return gems.every(type => bank[type] >= 1); } if (count === 2 && uniqueCount === 1) { const type = gems[0]; return bank[type] >= MIN_GEMS_FOR_TAKE_TWO_CLIENT; } return false; }
     function canAffordCardLocal(player, cardData) { if (!player || !cardData || !cardData.cost || !player.gems || !player.bonuses) { return false; } let goldNeeded = 0; for(const gemType of GEM_TYPES) { const cardCost = cardData.cost[gemType] ?? 0; const playerBonus = player.bonuses[gemType] ?? 0; const costAfterBonus = Math.max(0, cardCost - playerBonus); const playerHasGem = player.gems[gemType] ?? 0; if (playerHasGem < costAfterBonus) { goldNeeded += costAfterBonus - playerHasGem; } }; const playerHasGold = player.gems.gold ?? 0; return playerHasGold >= goldNeeded; }
     function getCardDataFromState(cardId) { if (!currentGameState || !cardId) return null; for (let level = 1; level <= 3; level++) { const card = currentGameState.visible_cards?.[level]?.find(c => c && c.id === cardId); if (card) return card; } for (const player of currentGameState.players || []) { const card = player.reservedCards?.find(c => c && c.id === cardId); if (card) return card; } return null; }
     function getDeckCardPlaceholder(level) { return { level: level, color: 'deck', cost: {}, vp: 0, id: `deck-${level}` }; }

     function clearActionState(localOnly = false) { clearGemSelectionState(localOnly); clearCardSelectionState(localOnly); currentAction = null; if (!localOnly) { renderSelectionInfo(); updateClickableState(); } }
     function clearGemSelectionState(localOnly = false) { gemBankContainer.querySelectorAll('.gem.selected').forEach(el => el.classList.remove('selected', 'preview-selection')); selectedGemTypes = []; if (!localOnly && currentAction === 'SELECTING_GEMS') { currentAction = null; } }
     function clearCardSelectionState(localOnly = false) { if (selectedCard && selectedCard.element) { selectedCard.element.classList.remove('selected', 'preview-selection'); } selectedCard = null; const existingPreview = selectionInfoDiv.querySelector('.card-preview-container'); if (existingPreview) existingPreview.remove(); selectionInfoDiv.querySelectorAll('.selection-text').forEach(p => { p.style.display = 'block'; }); if(selectedCardDisplay) selectedCardDisplay.textContent = 'None'; if (!localOnly && currentAction === 'SELECTING_CARD') { currentAction = null; } }

     function updateClickableState() { const state = currentGameState; const myTurnNow = isMyTurn; const isPendingActionForMe = state?.pending_action?.player_id === myPlayerId; const isSimulationRunning = state?.game_settings?.is_simulation ?? false; const blockAllInteractions = isGameOver || !isGameStarted || !webSocket || webSocket.readyState !== WebSocket.OPEN || isSimulationRunning; const allInteractiveElements = document.querySelectorAll( '#gem-bank .gem, #cards-area .card:not(.empty-slot), #cards-area .deck:not(.empty), .reserved-card-small, #pass-turn-btn, #confirm-return-gems-btn, #noble-choice-options .noble' ); allInteractiveElements.forEach(el => { el.classList.remove('interactive', 'card-affordable-now', 'not-affordable'); if(el.tagName === 'BUTTON') el.disabled = true; }); if (blockAllInteractions) { return; } if (isPendingActionForMe) { if (state.pending_action.type === "RETURN_GEMS") { returnGemsPlayerDisplay.querySelectorAll('.gem').forEach(gemEl => { if (gemEl.dataset.returnGemType !== GOLD) { gemEl.classList.add('interactive'); gemEl.onclick = () => toggleReturnGemSelection(gemEl); } else { gemEl.classList.remove('interactive'); gemEl.onclick = null; } }); confirmReturnGemsBtn.disabled = returnGemsSelection.length !== state.pending_action.count_needed; if (!confirmReturnGemsBtn.disabled) confirmReturnGemsBtn.classList.add('interactive'); } else if (state.pending_action.type === "CHOOSE_NOBLE") { nobleChoiceOptionsContainer.querySelectorAll('.noble').forEach(nobleEl => { nobleEl.classList.add('interactive'); /* onclick added when shown */ }); } return; } if (myTurnNow) { passTurnBtn.classList.add('interactive'); passTurnBtn.disabled = false; const player = state.players[myPlayerId]; const canReserveCheck = (player.reservedCards?.length ?? 0) < MAX_RESERVED_CARDS; gemBankContainer.querySelectorAll('.gem').forEach(gemEl => { const gemType = gemEl.dataset.gemType; if (gemType !== GOLD && (state.bank?.[gemType] ?? 0) > 0) { gemEl.classList.add('interactive'); } }); document.querySelectorAll('#cards-area .card:not(.empty-slot), #cards-area .deck:not(.empty)').forEach(el => { el.classList.add('interactive'); if(el.classList.contains('card')) { const cardData = getCardDataFromState(el.dataset.cardId); if(cardData && player) { const canAfford = canAffordCardLocal(player, cardData); el.classList.toggle('card-affordable-now', canAfford); el.classList.toggle('not-affordable', !canAfford); } } }); const myPlayerArea = document.getElementById(`player-area-${myPlayerId}`); if (myPlayerArea) { myPlayerArea.querySelectorAll('.reserved-card-small').forEach(cardEl => { cardEl.classList.add('interactive'); const cardData = player.reservedCards?.find(c => c.id === cardEl.dataset.cardId); if(cardData) { const canAfford = canAffordCardLocal(player, cardData); cardEl.classList.toggle('card-affordable-now', canAfford); cardEl.classList.toggle('not-affordable', !canAfford); } }); } } else { passTurnBtn.disabled = true; passTurnBtn.classList.remove('interactive'); } }

     function hideOverlays(keepGameOver = false) { const overlays = [returnGemsOverlay, nobleChoiceOverlay]; if (!keepGameOver && gameOverOverlay) { overlays.push(gameOverOverlay); } overlays.forEach(overlay => { if (overlay) overlay.classList.add('hidden'); }); returnGemsError.textContent = ''; nobleChoiceError.textContent = ''; }
     function showReturnGemsOverlay(player, currentTotalGems, gemsToReturnCount, nonGoldOwned) { returnGemsCountSpan.textContent = `${currentTotalGems} / ${MAX_GEMS_PLAYER}`; returnGemsNeededSpan.textContent = gemsToReturnCount; returnGemsPlayerDisplay.innerHTML = ''; returnGemsSelection = []; returnGemsError.textContent = ''; for (const type in nonGoldOwned) { if (GEM_TYPES.includes(type) && nonGoldOwned[type] > 0) { for (let i = 0; i < nonGoldOwned[type]; i++) { const gemEl = createGemElement(type, 1, false); gemEl.dataset.returnGemType = type; returnGemsPlayerDisplay.appendChild(gemEl); } } } const goldCount = player.gems?.[GOLD] ?? 0; if (goldCount > 0) { const goldEl = createGemElement(GOLD, goldCount, true); goldEl.style.cssText = 'opacity:0.5; cursor:not-allowed; margin-left:10px; width:25px; height:25px;'; goldEl.title = "Gold tokens cannot be returned"; if (goldEl.querySelector('.gem-count')) goldEl.querySelector('.gem-count').style.fontSize = '0.7em'; returnGemsPlayerDisplay.appendChild(goldEl); } confirmReturnGemsBtn.disabled = true; returnGemsSelectionDisplay.textContent = `Selected to return: 0 / ${gemsToReturnCount}`; confirmReturnGemsBtn.onclick = handleConfirmReturnGems; hideOverlays(); returnGemsOverlay.classList.remove('hidden'); updateClickableState(); }
     function toggleReturnGemSelection(gemEl) { const gemType = gemEl.dataset.returnGemType; const isSelected = gemEl.classList.contains('selected'); const needed = parseInt(returnGemsNeededSpan.textContent, 10); if (isSelected) { gemEl.classList.remove('selected', 'preview-return'); returnGemsSelection = returnGemsSelection.filter(item => item.gemEl !== gemEl); } else { if (returnGemsSelection.length < needed) { gemEl.classList.add('selected', 'preview-return'); returnGemsSelection.push({ gemEl: gemEl, type: gemType }); } else { returnGemsError.textContent = `Select exactly ${needed} gems.`; setTimeout(() => { returnGemsError.textContent = ''; }, 2000); } } const selectedCount = returnGemsSelection.length; returnGemsSelectionDisplay.textContent = `Selected to return: ${selectedCount} / ${needed}`; confirmReturnGemsBtn.disabled = selectedCount !== needed; confirmReturnGemsBtn.classList.toggle('interactive', !confirmReturnGemsBtn.disabled); returnGemsError.textContent = ''; }
     function handleConfirmReturnGems() { if (confirmReturnGemsBtn.disabled) return; const gemsToReturn = returnGemsSelection.map(item => item.type); sendWebSocketMessage({ type: "RETURN_GEMS", payload: { gems: gemsToReturn } }); confirmReturnGemsBtn.disabled = true; confirmReturnGemsBtn.classList.remove('interactive'); }
     function showNobleChoiceOverlay(player, eligibleNoblesData) { nobleChoiceOptionsContainer.innerHTML = ''; nobleChoiceError.textContent = ''; if (!eligibleNoblesData || eligibleNoblesData.length === 0) { console.error("showNobleChoiceOverlay called with no nobles"); return; } eligibleNoblesData.forEach(nobleData => { const nobleEl = createNobleElement(nobleData); nobleEl.onclick = () => handleNobleChoiceSelection(nobleData.id); nobleChoiceOptionsContainer.appendChild(nobleEl); }); hideOverlays(); nobleChoiceOverlay.classList.remove('hidden'); updateClickableState(); }
     function handleNobleChoiceSelection(nobleId) { sendWebSocketMessage({ type: "CHOOSE_NOBLE", payload: { nobleId: nobleId } }); nobleChoiceOptionsContainer.querySelectorAll('.noble').forEach(n => n.classList.remove('interactive')); }
     function renderGameOver(gameOverData) { finalScoresDiv.innerHTML = ''; if (!gameOverData || !gameOverData.player_stats) { finalScoresDiv.textContent = "Error displaying final scores."; return; } const scores = gameOverData.scores || {}; const stats = gameOverData.player_stats || {}; const winnerIds = new Set((gameOverData.winners || []).map(w => w.id)); const playersForSort = Object.entries(stats).map(([idStr, pStats]) => { const id = parseInt(idStr, 10); const winnerData = gameOverData.winners?.find(w => w.id === id); const playerInfo = currentGameState?.players?.find(p => p.id === id); const name = winnerData?.name || playerInfo?.name ||`Player ${id + 1}`; const type = winnerData?.type || playerInfo?.type || 'unknown'; return { id: id, score: scores[id] || 0, cardsPurchasedCount: pStats.cardsPurchasedCount || 0, name: name, type: type, stats: pStats, }; }); playersForSort.sort((a, b) => { if (b.score !== a.score) return b.score - a.score; return a.cardsPurchasedCount - b.cardsPurchasedCount; }); playersForSort.forEach((p, index) => { const rank = index + 1; const isWinner = winnerIds.has(p.id); const playerStats = p.stats; const vpFromCards = 0; const vpFromNobles = (playerStats.noblesAcquiredTurn ? Object.keys(playerStats.noblesAcquiredTurn).length : 0) * 3; const avgVpPerTurn = (playerStats.turnsTaken ?? 0) > 0 ? (p.score / playerStats.turnsTaken).toFixed(2) : 'N/A'; const avgVpPerCard = (playerStats.cardsPurchasedCount ?? 0) > 0 ? (p.score / playerStats.cardsPurchasedCount).toFixed(2) : 'N/A'; const reservationSuccessRate = (playerStats.cardsReservedTotalCount ?? 0) > 0 ? (((playerStats.purchasedFromReserveCount??0) / playerStats.cardsReservedTotalCount) * 100).toFixed(1) : '0.0'; const totalBonuses = 0; const avgBonusPerCard = 'N/A'; const totalGemsTaken = Object.values(playerStats.gemsTaken ?? {}).reduce((s, c) => s + c, 0); const totalGemTakeActions = (playerStats.take2Actions??0) + (playerStats.take3Actions??0); const avgGemsPerTakeAction = totalGemTakeActions > 0 ? (totalGemsTaken / totalGemTakeActions).toFixed(2) : 'N/A'; const percentTake3 = totalGemTakeActions > 0 ? (((playerStats.take3Actions??0) / totalGemTakeActions) * 100).toFixed(1) : 'N/A'; const percentTake2 = totalGemTakeActions > 0 ? (((playerStats.take2Actions??0) / totalGemTakeActions) * 100).toFixed(1) : 'N/A'; const totalGemsSpent = Object.values(playerStats.gemsSpent ?? {}).reduce((s, c) => s + c, 0); const totalSpending = totalGemsSpent + (playerStats.goldSpent??0); const goldDependency = totalSpending > 0 ? (((playerStats.goldSpent??0) / totalSpending) * 100).toFixed(1) : '0.0'; const totalGemsReturned = Object.values(playerStats.gemsReturnedOverLimit ?? {}).reduce((s, c) => s + c, 0); const totalActions = (playerStats.gemTakeActions??0) + (playerStats.purchaseActions??0) + (playerStats.reserveActions??0); const actionDist = { gem: totalActions > 0 ? (((playerStats.gemTakeActions??0) / totalActions) * 100).toFixed(1) : 'N/A', purchase: totalActions > 0 ? (((playerStats.purchaseActions??0) / totalActions) * 100).toFixed(1) : 'N/A', reserve: totalActions > 0 ? (((playerStats.reserveActions??0) / totalActions) * 100).toFixed(1) : 'N/A' }; const playerEntryDiv = document.createElement('details'); playerEntryDiv.classList.add('player-result-entry-detailed'); if (isWinner) playerEntryDiv.classList.add('winner'); playerEntryDiv.open = (rank === 1); const summary = document.createElement('summary'); summary.classList.add('player-result-header-detailed'); let rankSuffix = 'th'; if (rank === 1 && playersForSort.filter(pl => pl.score === p.score).length > 1 && !isWinner) rankSuffix = 'st (Tied)'; else if (rank === 1) rankSuffix = 'st'; else if (rank === 2) rankSuffix = 'nd'; else if (rank === 3) rankSuffix = 'rd'; summary.innerHTML = `<span class="player-rank">${isWinner ? '🏆' : ''} ${rank}${rankSuffix}</span> <span class="player-name-endgame">${p.name} ${p.type === 'ai' ? '[AI]' : ''} ${playerStats.isFirstPlayer ? '(P1)' : ''} ${playerStats.triggeredGameEnd ? '[Triggered End]' : ''}</span> <span class="player-score-endgame">${p.score} VP</span> <span class="player-summary-stats">(Cards: ${p.cardsPurchasedCount} | Turns: ${playerStats.turnsTaken??'N/A'})</span>`; playerEntryDiv.appendChild(summary); const detailsContainer = document.createElement('div'); detailsContainer.classList.add('player-result-details-grid'); const col1 = document.createElement('div'); col1.classList.add('stat-column'); col1.innerHTML = `<div class="stat-category"><h4>VP Breakdown</h4><div class="stat-items"><span>Cards: ${vpFromCards} VP (Approx.)</span><span>Nobles: ${vpFromNobles} VP (Approx.)</span>${playerStats.turnReached15VP ? `<span>Reached 15 VP: Turn ${playerStats.turnReached15VP}</span>` : ''}</div></div><div class="stat-category"><h4>Purchased (${p.cardsPurchasedCount}) <span class="details-inline">(L1:${playerStats.cardsPurchasedByLevel?.[1] ?? 0}/L2:${playerStats.cardsPurchasedByLevel?.[2] ?? 0}/L3:${playerStats.cardsPurchasedByLevel?.[3] ?? 0})</span></h4><div class="stat-items sub-stats"><span>Avg VP/Card: ${avgVpPerCard}</span><span>From Reserve: ${playerStats.purchasedFromReserveCount??0} / Board: ${playerStats.purchasedFromBoardCount??0}</span><span>Free Purchases: ${playerStats.selfSufficientPurchases??0}</span></div></div><div class="stat-category"><h4>Reserved History (${playerStats.cardsReservedTotalCount??0} Total)</h4><div class="stat-items sub-stats"><span>Deck Res (L1/L2/L3): ${playerStats.deckReservations?.[1] ?? 0}/${playerStats.deckReservations?.[2] ?? 0}/${playerStats.deckReservations?.[3] ?? 0}</span><span>Board Res (L1/L2/L3): ${playerStats.boardReservations?.[1] ?? 0}/${playerStats.boardReservations?.[2] ?? 0}/${playerStats.boardReservations?.[3] ?? 0}</span><span>Purchase Rate: ${reservationSuccessRate}%</span></div></div><div class="stat-category"><h4>Nobles Acquired (${playerStats.noblesAcquiredTurn ? Object.keys(playerStats.noblesAcquiredTurn).length : 0})</h4><div class="stat-items sub-stats">${playerStats.noblesAcquiredTurn ? Object.entries(playerStats.noblesAcquiredTurn).map(([id, turn]) => `<span>Noble ${id.split('-')[1]} (Turn ${turn})</span>`).join('') : '<span class="no-items">None</span>'}</div></div>`; detailsContainer.appendChild(col1); const col2 = document.createElement('div'); col2.classList.add('stat-column'); const takenStr = playerStats.gemsTaken ? Object.entries(playerStats.gemsTaken).filter(([,c])=>c>0).map(([t,c])=>`${c} ${t}`).join(', ') : '0'; const spentStr = playerStats.gemsSpent ? Object.entries(playerStats.gemsSpent).filter(([,c])=>c>0).map(([t,c])=>`${c} ${t}`).join(', ') : '0'; const returnedStr = playerStats.gemsReturnedOverLimit ? Object.entries(playerStats.gemsReturnedOverLimit).filter(([,c])=>c>0).map(([t,c])=>`${c} ${t}`).join(', ') : '0'; col2.innerHTML = `<div class="stat-category"><h4>Bonuses (${totalBonuses} Total Approx.)</h4><div class="stat-items sub-stats"><span>Avg Bonus/Card: ${avgBonusPerCard}</span></div></div><div class="stat-category"><h4>Token Management</h4><div class="stat-items sub-stats flow-stats"><span>Taken: ${takenStr || '0'} (${totalGemsTaken} total)</span><span>Gold Taken: ${playerStats.goldTaken??0}</span><span>Spent: ${spentStr || '0'} (${totalGemsSpent} total)</span><span>Gold Spent: ${playerStats.goldSpent??0} (${goldDependency}% of cost)</span><span>Returned (Limit): ${returnedStr || '0'} (${totalGemsReturned} total)</span><span>Peak Held (Total): ${playerStats.peakGemsHeld??0}</span></div><h4>Token Actions</h4><div class="stat-items sub-stats"><span>Take 3 Actions: ${playerStats.take3Actions??0} (${percentTake3}%)</span><span>Take 2 Actions: ${playerStats.take2Actions??0} (${percentTake2}%)</span><span>Avg Tokens/Take Action: ${avgGemsPerTakeAction}</span></div><h4>Token Limit Interaction</h4><div class="stat-items sub-stats"><span>Turns Ended at Limit: ${playerStats.turnsEndedExactLimit??0}</span><span>Turns Ended Below Limit: ${playerStats.turnsEndedBelowLimit??0}</span></div></div><div class="stat-category"><h4>Action Distribution (${totalActions} Total)</h4><div class="stat-items action-dist-stats"><span>Token Takes: ${actionDist.gem}%</span><span>Purchases: ${actionDist.purchase}%</span><span>Reserves: ${actionDist.reserve}%</span></div><div class="stat-items sub-stats"><span>Avg VP/Turn: ${avgVpPerTurn}</span></div></div>`; detailsContainer.appendChild(col2); playerEntryDiv.appendChild(detailsContainer); finalScoresDiv.appendChild(playerEntryDiv); }); if (winnerIds.size > 1) { const tieMessage = document.createElement('p'); tieMessage.classList.add('tie-message'); const winnerNames = playersForSort.filter(p => winnerIds.has(p.id)).map(p => p.name).join(' & '); tieMessage.textContent = `Tie between: ${winnerNames}! (Fewest cards purchased wins)`; finalScoresDiv.appendChild(tieMessage); } }

    showScreen('setup-join-screen');
    resetLobbyState();
    console.log("Splendor Multiplayer Client Initialized (with Simulation support).");

});
```
--- END OF FILE splendor_frontend/script.js ---

--- START OF FILE splendor_frontend/style.css ---
```css
:root {
    --bg-primary: #1a1d21;
    --bg-secondary: #2c313a;
    --bg-tertiary: #23272e;
    --bg-quaternary: #353a45;
    --bg-log: #282c34;
    --bg-log-alt: #2f343d;
    --bg-modal: #3a404a;
    --bg-input: #2c313a;
    --bg-card: linear-gradient(135deg, #4a4f5a 0%, #3a3f4a 100%);
    --bg-card-cost: rgba(20, 20, 20, 0.5);
    --bg-noble: #4b443a;
    --bg-deck: #40454f;
    --bg-deck-empty: #2c313a;
    --bg-deck-hover: #505662;
    --bg-player-area: #353a45;
    --bg-reserved-area: #282c34;
    --bg-winner: #5a4d2e;
    --btn-bg: #546e7a;
    --btn-bg-hover: #607d8b;
    --btn-bg-disabled: #455a64;
    --btn-bg-cancel: #78909c;
    --btn-bg-cancel-hover: #90a4ae;
    --btn-bg-start: #f39c12;
    --btn-bg-start-hover: #e67e22;

    --text-primary: #e0e4e8;
    --text-secondary: #b0b8c0;
    --text-tertiary: #8892a0;
    --text-heading: #d0d8e0;
    --text-vp: #f5c542;
    --text-vp-noble: #e8b36f;
    --text-white-gem: #333;
    --text-button: #ffffff;
    --text-button-disabled: #90a4ae;
    --text-timer: #e74c3c;
    --text-timer-low: #f56545;
    --text-error: #ef5350;
    --text-success: #66bb6a;
    --text-setup-title: #f5c542;
    --text-setup-label: #b0b8c0;

    --border-primary: #555e6a;
    --border-secondary: #778290;
    --border-tertiary: #99a2b0;
    --border-divider: #444a54;
    --border-noble: #d4af37;
    --border-gold-gem: #f39c12;
    --border-card-cost: rgba(255,255,255,0.1);
    --border-card-gem: rgba(255, 255, 255, 0.2);
    --border-input: #555e6a;
    --border-gem-subtle: rgba(255,255,255,0.15);
    --border-setup: rgba(243, 156, 18, 0.3);

    --shadow-primary: rgba(0, 0, 0, 0.25);
    --shadow-secondary: rgba(0, 0, 0, 0.35);
    --shadow-card: 0 3px 6px rgba(0,0,0,0.3), 0 2px 4px rgba(0,0,0,0.25);
    --shadow-card-hover: 0 5px 10px rgba(0,0,0,0.4), 0 3px 6px rgba(0,0,0,0.35);
    --shadow-modal: rgba(0, 0, 0, 0.6);
    --shadow-gem: 0 2px 4px rgba(0,0,0,0.45);
    --shadow-gem-inner: inset 0 1px 2px rgba(255,255,255,0.15), inset 0 -1px 3px rgba(0,0,0,0.4);
    --shadow-gem-hover: 0 4px 8px rgba(0,0,0,0.55);
    --shadow-overlay: rgba(0, 0, 0, 0.75);
    --shadow-input: inset 0 1px 3px rgba(0, 0, 0, 0.4);
    --shadow-button-start: 0 4px 8px rgba(0, 0, 0, 0.3);

    --highlight-active: #f5c542;
    --highlight-selected: gold;
    --highlight-selected-return: #e53935;
    --highlight-interactive: #64b5f6;

    --opacity-disabled: 0.4;
    --opacity-affordable: 0.6;

    --player-color-1-border: #e74c3c;
    --player-color-1-bg-subtle: rgba(231, 76, 60, 0.1);
    --player-color-2-border: #3498db;
    --player-color-2-bg-subtle: rgba(52, 152, 219, 0.1);
    --player-color-3-border: #2ecc71;
    --player-color-3-bg-subtle: rgba(46, 204, 113, 0.1);
    --player-color-4-border: #f1c40f;
    --player-color-4-bg-subtle: rgba(241, 196, 15, 0.1);
}

body { font-family: 'Roboto', sans-serif; margin: 0; background-color: var(--bg-primary); color: var(--text-primary); display: flex; justify-content: center; align-items: center; min-height: 100vh; font-size: 14px; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; transition: background-color 0.3s ease, color 0.3s ease; }
#game-container { padding: 15px; width: 100%; max-width: 1700px; margin: 0 auto; box-sizing: border-box; transition: opacity 0.5s ease-in-out; }
.hidden { display: none !important; }
.active { display: block; }
#setup-join-screen.active { display: flex; }
#game-container.active { display: block; }
h1, h2, h3 { font-family: 'Cinzel Decorative', cursive; color: var(--text-heading); margin-top: 0; }
h2 { margin-bottom: 10px; font-size: 1.4em; }
h3 { margin-bottom: 15px; font-size: 1.2em; border-bottom: 1px solid var(--border-divider); padding-bottom: 8px;}
h4 { margin: 8px 0 4px 0; font-size: 1em; color: var(--text-secondary); font-weight: 700; }
button { font-family: 'Roboto', sans-serif; padding: 8px 15px; border: none; border-radius: 5px; background-color: var(--btn-bg); color: var(--text-button); cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease, opacity 0.2s ease; margin: 5px 2px; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; min-width: 100px; text-align: center; }
button:hover:not(:disabled) { background-color: var(--btn-bg-hover); transform: translateY(-1px); }
button:active:not(:disabled) { transform: translateY(0px); }
button:disabled { background-color: var(--btn-bg-disabled); color: var(--text-button-disabled); cursor: not-allowed; transform: none; opacity: 0.7; }

#setup-join-screen { width: 100%; min-height: 100vh; justify-content: center; align-items: center; background: radial-gradient(ellipse at center, rgba(44, 49, 58, 0.8) 0%, rgba(26, 29, 33, 0.95) 70%), linear-gradient(160deg, var(--bg-primary) 0%, var(--bg-secondary) 100%); padding: 40px; box-sizing: border-box; opacity: 0; animation: fadeInSetup 0.8s 0.2s ease-out forwards; }
@keyframes fadeInSetup { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
.setup-content { background-color: rgba(35, 39, 46, 0.85); padding: 30px 40px; border-radius: 15px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), inset 0 0 0 1px var(--border-setup); text-align: center; max-width: 600px; width: 100%; backdrop-filter: blur(3px); }
.setup-title { font-size: 2.8em; color: var(--text-setup-title); margin-bottom: 10px; text-shadow: 0 2px 5px rgba(0, 0, 0, 0.6); }
.setup-subtitle { font-size: 1.1em; color: var(--text-secondary); margin-bottom: 30px; font-weight: 300; }
.setup-option { margin-bottom: 20px; text-align: left; }
.setup-label { display: block; margin-bottom: 8px; font-weight: 400; user-select: auto; color: var(--text-setup-label); font-size: 1.0em; }
.setup-input { padding: 10px 12px; border-radius: 6px; border: 1px solid var(--border-input); margin-bottom: 5px; width: 100%; box-sizing: border-box; user-select: text; background-color: var(--bg-input); color: var(--text-primary); font-size: 1em; box-shadow: var(--shadow-input); transition: border-color 0.2s ease, box-shadow 0.2s ease; }
.setup-input:focus { outline: none; border-color: var(--highlight-active); box-shadow: var(--shadow-input), 0 0 0 2px rgba(245, 197, 66, 0.3); }
select.setup-input { appearance: none; -webkit-appearance: none; -moz-appearance: none; background-image: url('data:image/svg+xml;utf8,<svg fill="%23b0b8c0" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>'); background-repeat: no-repeat; background-position: right 10px center; background-size: 20px; cursor: pointer; padding-right: 35px; }
.setup-start-button { margin-top: 15px; padding: 14px 30px; font-size: 1.2em; background-color: var(--btn-bg-start); color: var(--bg-primary); font-weight: 700; border-radius: 8px; box-shadow: var(--shadow-button-start); letter-spacing: 0.5px; display: inline-flex; align-items: center; justify-content: center; gap: 10px; }
.setup-start-button:hover:not(:disabled) { background-color: var(--btn-bg-start-hover); transform: translateY(-2px) scale(1.02); box-shadow: 0 6px 12px rgba(0, 0, 0, 0.35); }
.setup-start-button:active:not(:disabled) { transform: translateY(0px) scale(1); box-shadow: var(--shadow-button-start); }
.start-icon { font-size: 0.9em; line-height: 1; }
.action-buttons { display: flex; flex-direction: column; gap: 15px; margin-top: 20px; }
.action-buttons .divider { border: none; height: 1px; background-color: var(--border-divider); margin: 10px 0; }
#initial-options, #create-game-options, #waiting-lobby { width: 100%; }
.secondary-button { background-color: var(--btn-bg-cancel); }
.secondary-button:hover:not(:disabled) { background-color: var(--btn-bg-cancel-hover); }
#waiting-lobby { text-align: center; margin-top: 20px; padding: 20px; background-color: rgba(255, 255, 255, 0.05); border-radius: 8px; }
#display-game-code { background-color: var(--bg-input); padding: 5px 10px; border-radius: 4px; font-family: monospace; font-size: 1.2em; color: var(--highlight-active); margin: 0 5px; user-select: all; }
#copy-code-btn { background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 1.1em; padding: 0 5px; min-width: auto; vertical-align: middle; }
#copy-code-btn:hover { color: var(--highlight-active); }
#lobby-player-list { list-style: none; padding: 0; margin: 15px 0; max-height: 150px; overflow-y: auto; text-align: left; }
#lobby-player-list li { background-color: var(--bg-tertiary); padding: 8px 12px; margin-bottom: 5px; border-radius: 4px; border-left: 4px solid var(--border-secondary); display: flex; justify-content: space-between; align-items: center; }
#lobby-player-list li.player-self { border-left-color: var(--highlight-active); font-weight: bold; }
#lobby-player-list li .player-type-indicator { font-size: 0.8em; color: var(--text-tertiary); margin-left: 10px; font-style: italic; }
.status-message { font-size: 0.9em; color: var(--text-secondary); margin-top: 10px; min-height: 1.2em; }
.error-message { font-size: 0.9em; color: var(--text-error); margin-top: 10px; min-height: 1.2em; font-weight: bold; }
#player-configs-area { margin-top: 15px; margin-bottom: 20px; border: 1px solid var(--border-input); border-radius: 6px; padding: 15px; background-color: rgba(0,0,0,0.1); }
.player-config-entry { display: grid; grid-template-columns: auto 1fr auto auto; gap: 10px 15px; align-items: center; margin-bottom: 12px; padding-bottom: 10px; border-bottom: 1px dashed var(--border-divider); }
.player-config-entry:last-child { margin-bottom: 0; padding-bottom: 0; border-bottom: none; }
.player-config-label { font-weight: bold; color: var(--text-secondary); text-align: right; }
.player-config-name { font-weight: normal; color: var(--text-primary); }
.player-type-select, .player-model-select { padding: 6px 8px; font-size: 0.9em; background-size: 16px; margin-bottom: 0; width: auto; min-width: 120px; cursor: pointer;}
.player-type-select:disabled { cursor: not-allowed; opacity: 0.7; }
.player-model-select.hidden { visibility: hidden; }
.player-model-select:disabled { cursor: not-allowed; opacity: 0.7; }
.setup-option small { display: block; margin-left: 5px; margin-top: 3px; font-size: 0.85em; color: var(--text-tertiary); }

#game-board { display: flex; flex-direction: column; gap: 15px; background-color: var(--bg-tertiary); border-radius: 10px; box-shadow: 0 5px 20px var(--shadow-secondary); overflow: hidden; padding: 15px; }
#top-bar { display: grid; grid-template-columns: 1fr auto 1fr; align-items: flex-start; background-color: var(--bg-quaternary); padding: 15px 20px; border-radius: 8px; gap: 20px; }
#nobles-area, #timer-area, #game-status { padding: 0 10px; }
#nobles-area h2, #timer-area h2, #game-status h2 { text-align: center; margin-bottom: 10px; }
.nobles-container { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; min-height: 75px; }
#timer-area { text-align: center; }
#timer-display { font-size: 2em; text-align: center; font-weight: 700; color: var(--text-primary); background-color: var(--bg-secondary); padding: 5px 10px; border-radius: 5px; min-width: 80px; display: inline-block; box-shadow: inset 0 1px 3px var(--shadow-gem); user-select: none; }
#log-messages { height: 100px; overflow-y: auto; border: 1px solid var(--border-primary); padding: 5px 8px; font-size: 0.9em; background-color: var(--bg-log); color: var(--text-secondary); border-radius: 4px; margin-bottom: 8px; }
#log-messages p { margin: 2px 0; padding: 2px 4px; user-select: text; color: var(--text-primary); line-height: 1.4; }
#log-messages p:nth-child(odd) { background-color: var(--bg-log-alt); }
#game-status { text-align: center;}
#game-status button { margin-top: 5px; }
#server-message { margin-top: 8px; font-weight: bold; display: block; min-height: 1.2em; }
#main-area { display: flex; gap: 20px; flex-wrap: nowrap; }
#bank-area { flex: 0 0 280px; background-color: var(--bg-quaternary); padding: 15px; border-radius: 8px; display: flex; flex-direction: column; align-items: center; }
#bank-area h2 { text-align: center; }
.gems-container { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-bottom: 15px; }
.gem { width: 45px; height: 45px; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-weight: bold; color: white; font-size: 1.2em; position: relative; border: 1px solid var(--border-gem-subtle); box-shadow: var(--shadow-gem-inner), var(--shadow-gem); transition: transform 0.2s ease-out, box-shadow 0.2s ease-out, outline 0.2s ease, opacity 0.3s ease; user-select: none; }
.gem.interactive:hover { transform: scale(1.05); box-shadow: var(--shadow-gem-inner), var(--shadow-gem-hover); outline: 2px solid var(--highlight-interactive); outline-offset: 1px; }
.gem.selected { transform: scale(1.15) !important; outline: 3px solid var(--highlight-selected); outline-offset: 1px; box-shadow: var(--shadow-gem-inner), 0 4px 10px rgba(0,0,0,0.6); }
.gem-count { position: absolute; bottom: -8px; right: -5px; background-color: rgba(0,0,0,0.85); color: white; font-size: 0.8em; padding: 2px 5px; border-radius: 50%; min-width: 18px; text-align: center; user-select: none; border: 1px solid rgba(255,255,255,0.2); }
.small-gems .gem { width: 25px; height: 25px; font-size: 0.9em; cursor: default; box-shadow: var(--shadow-gem-inner), 0 1px 2px rgba(0,0,0,0.25); border-width: 1px; }
.small-gems .gem.interactive:hover { transform: scale(1.05); box-shadow: var(--shadow-gem-inner), 0 1px 3px rgba(0,0,0,0.35); }
.small-gems .gem-count { font-size: 0.7em; min-width: 14px; padding: 1px 3px; bottom: -5px; right: -3px; user-select: none; }
.small-gems { gap: 5px; margin-bottom: 5px; }
#selection-info { font-size: 0.9em; text-align: center; margin-top: 15px; background-color: var(--bg-secondary); padding: 12px; border-radius: 6px; color: var(--text-secondary); border: 1px solid var(--border-primary); user-select: none; min-height: 230px; display: flex; flex-direction: column; justify-content: flex-start; box-sizing: border-box; width: 100%; }
#selection-info .selection-text { margin: 5px 0; }
#selection-info p span { font-weight: bold; color: var(--text-primary); }
#selection-info #selected-gems-display { display: flex; align-items: center; justify-content: center; flex-wrap: wrap; min-height: 25px; }
#selection-info #selected-gems-display .gem { margin: 0 1px; }
.card-preview-container { flex-grow: 1; display: flex; justify-content: center; align-items: center; margin-bottom: 10px; width: 100%; min-height: 150px; }
.card-preview { transform: scale(1.15); cursor: default; box-shadow: 0 4px 12px rgba(0,0,0,0.4); transition: none !important; pointer-events: none; }
.card-preview:hover { transform: scale(1.15); box-shadow: 0 4px 12px rgba(0,0,0,0.4); }
#dynamic-action-buttons { margin-top: auto; padding-top: 8px; display: flex; flex-direction: column; align-items: center; gap: 6px; }
#dynamic-action-buttons button.action-possible { border: 1px solid var(--highlight-active); box-shadow: 0 0 5px rgba(245, 197, 66, 0.3); }
#cards-area { flex: 1 1 auto; display: flex; flex-direction: column; gap: 10px; overflow: hidden; }
.card-level-row { background-color: var(--bg-quaternary); padding: 10px 15px; border-radius: 8px; display: flex; align-items: center; gap: 15px; }
.card-level-row h3 { writing-mode: vertical-rl; text-orientation: mixed; margin: 0; margin-right: 5px; color: var(--text-secondary); flex-shrink: 0; }
.deck { width: 95px; height: 140px; border: 2px dashed var(--border-secondary); border-radius: 8px; display: flex; flex-wrap: wrap; justify-content: center; align-items: center; text-align: center; font-size: 0.9em; color: var(--text-tertiary); background-color: var(--bg-deck); transition: transform 0.2s ease-out, box-shadow 0.2s ease-out, outline 0.2s ease, opacity 0.3s ease, background-color 0.2s; user-select: none; padding: 5px; box-sizing: border-box; gap: 0.2em; line-height: 1.2; flex-shrink: 0; }
.deck span { font-size: 1.1em; font-weight: bold; display: inline; }
.deck.interactive:hover:not(.empty) { background-color: var(--bg-deck-hover); transform: scale(1.02); }
.deck.selected { border: 3px solid var(--highlight-selected); box-shadow: inset 0 0 8px rgba(255, 215, 0, 0.3); }
.deck.empty { background-color: var(--bg-deck-empty); cursor: not-allowed; border-color: var(--border-primary); opacity: 0.7; pointer-events: none; }
.deck.empty:hover { background-color: var(--bg-deck-empty); }
.visible-cards { display: flex; gap: 15px; flex-grow: 1; min-height: 145px; justify-content: flex-start; }
.card { width: 95px; height: 140px; border-radius: 8px; position: relative; background: var(--bg-card); box-shadow: var(--shadow-card); transition: transform 0.2s ease-out, box-shadow 0.2s ease-out, outline 0.2s ease, opacity 0.3s ease; overflow: hidden; display: flex; flex-direction: column; border: 3px solid var(--border-tertiary); font-family: 'Roboto', sans-serif; box-sizing: border-box; user-select: none; flex-shrink: 0; }
.card.interactive:hover { transform: translateY(-4px) scale(1.02); box-shadow: var(--shadow-card-hover); outline: 2px solid var(--highlight-interactive); outline-offset: 1px; }
.card.selected { transform: scale(1.08) translateY(-3px) !important; outline: 3px solid var(--highlight-selected); outline-offset: 2px; box-shadow: 0 8px 16px var(--shadow-secondary), 0 3px 6px var(--shadow-secondary); }
.card.not-affordable { opacity: var(--opacity-affordable); }
.card.empty-slot { background: repeating-linear-gradient( 45deg, var(--bg-deck-empty), var(--bg-deck-empty) 10px, var(--bg-deck) 10px, var(--bg-deck) 20px ); border: 2px dashed var(--border-secondary); box-shadow: none; cursor: default; color: var(--text-tertiary); display: flex; justify-content: center; align-items: center; opacity: 0.5; pointer-events: none; }
.card-top-area { display: flex; justify-content: space-between; align-items: center; padding: 5px 7px; height: 30px; box-sizing: border-box; }
.card-vp { font-weight: 700; font-size: 1.5em; color: var(--text-vp); font-family: 'Cinzel Decorative', cursive; line-height: 1; text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.4); margin-left: -2px; }
.card-vp:empty { display: block; width: 1em; content: ''; }
.card-gem-bonus { width: 22px; height: 22px; border-radius: 50%; border: 1px solid var(--border-card-gem); box-shadow: inset 0 0 3px rgba(0,0,0,0.6), 1px 1px 2px rgba(0,0,0,0.4); position: relative; flex-shrink: 0; background-clip: padding-box; }
.card-gem-bonus::before { content: ''; position: absolute; top: 3px; left: 3px; width: 6px; height: 3px; background: rgba(255, 255, 255, 0.2); border-radius: 50% / 40%; transform: rotate(45deg); filter: blur(0.5px); }
.card-center-area { flex-grow: 1; display: flex; justify-content: center; align-items: center; color: var(--text-tertiary); font-size: 2.5em; opacity: 0.6; }
[data-level="1"] .card-center-area::before { content: '⛏️'; } [data-level="2"] .card-center-area::before { content: '⚙️'; } [data-level="3"] .card-center-area::before { content: '👑'; }
.card-cost-area { display: flex; flex-direction: row; flex-wrap: wrap; align-items: center; justify-content: flex-start; padding: 4px 6px; gap: 2px 4px; min-height: auto; background: var(--bg-card-cost); border-top: 1px solid var(--border-card-cost); margin: auto 4px 4px 4px; border-radius: 4px; box-sizing: border-box; }
.cost-item { font-size: 1.0em; font-weight: 700; display: flex; align-items: baseline; gap: 3px; color: var(--text-primary); text-shadow: 1px 1px 0px rgba(0,0,0,0.3); background-color: transparent; padding: 1px 2px; border-radius: 3px; }
.cost-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; vertical-align: middle; margin-right: 1px; border: 1px solid rgba(0,0,0,0.2); }
.card-border-white { border-color: #c7c7c7; } .card-border-blue { border-color: #3498db; } .card-border-green { border-color: #2ecc71; } .card-border-red { border-color: #e74c3c; } .card-border-black { border-color: #34495e; }
.card-affordable-now:not(.selected).interactive { outline: 2px solid rgba(245, 197, 66, 0.7); outline-offset: 0px; box-shadow: 0 0 8px rgba(245, 197, 66, 0.3); }
.card-affordable-now:not(.selected).interactive:hover { outline-color: rgba(245, 197, 66, 1); outline-offset: 1px; box-shadow: 0 0 12px rgba(245, 197, 66, 0.5); }
.noble { width: 70px; height: 70px; border: 2px solid var(--border-noble); border-radius: 8px; background-color: var(--bg-noble); padding: 5px; display: flex; flex-direction: column; align-items: center; justify-content: space-between; box-shadow: 0 2px 5px var(--shadow-gem); user-select: none; transition: transform 0.2s ease-out, box-shadow 0.2s ease-out, outline 0.2s ease, opacity 0.3s ease; flex-shrink: 0; }
.noble-vp { font-weight: bold; font-size: 1.4em; color: var(--text-vp-noble); font-family: 'Cinzel Decorative', cursive; }
.noble-requirements { display: flex; gap: 3px; flex-wrap: wrap; justify-content: center; }
.req-item { font-size: 0.9em; font-weight: bold; display: flex; align-items: center; background-color: rgba(255,255,255,0.1); padding: 1px 3px; border-radius: 3px; color: var(--text-primary); }
.req-gem { width: 10px; height: 10px; border-radius: 50%; margin-left: 3px; display: inline-block; border: 1px solid var(--border-secondary); }
#players-area { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px; margin-top: 15px; }
.player-area { border: 2px solid var(--border-primary); border-radius: 8px; padding: 15px; background-color: var(--bg-player-area); box-shadow: 0 3px 8px var(--shadow-primary); transition: border-color 0.3s ease, box-shadow 0.3s ease, background-color 0.3s ease; user-select: none; position: relative; }
.player-area.player-color-1 { border-top: 4px solid var(--player-color-1-border); background-color: var(--player-color-1-bg-subtle); } .player-area.player-color-2 { border-top: 4px solid var(--player-color-2-border); background-color: var(--player-color-2-bg-subtle); } .player-area.player-color-3 { border-top: 4px solid var(--player-color-3-border); background-color: var(--player-color-3-bg-subtle); } .player-area.player-color-4 { border-top: 4px solid var(--player-color-4-border); background-color: var(--player-color-4-bg-subtle); }
.player-area.active-player { border-color: var(--highlight-active) !important; border-top-width: 4px; box-shadow: 0 0 15px rgba(245, 197, 66, 0.5); }
.player-area.player-self-area { background-color: rgba(255, 255, 255, 0.03); }
.player-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; border-bottom: 1px solid var(--border-divider); padding-bottom: 5px; }
.player-name { font-weight: 700; font-size: 1.1em; user-select: text; color: var(--text-primary); }
.player-area.active-player .player-name { color: var(--highlight-active); }
.player-score { font-weight: 700; font-size: 1.2em; color: var(--text-vp); }
.ai-badge { position: absolute; top: 5px; right: 5px; background-color: rgba(0, 0, 0, 0.6); color: #aaa; font-size: 0.7em; padding: 2px 4px; border-radius: 3px; font-weight: bold; z-index: 1; }
.player-resources { }
.player-cards { display: flex; flex-wrap: wrap; gap: 5px; margin-top: 5px; justify-content: center; min-height: 30px; }
.player-card-count { width: 28px; height: 28px; border-radius: 5px; display: flex; justify-content: center; align-items: center; font-weight: bold; color: white; font-size: 0.9em; border: 1px solid var(--border-secondary); box-shadow: inset 0 0 2px rgba(0,0,0,0.6); }
.total-gems-indicator { font-weight: bold; margin-left: 8px; font-size: 0.9em; display: block; text-align: right; margin-top: 5px;}
.reserved-cards-container { display: flex; gap: 5px; margin-top: 5px; min-height: 70px; background-color: var(--bg-reserved-area); padding: 5px; border-radius: 4px; align-items: flex-start; flex-wrap: wrap; }
.reserved-card-small { width: 45px; height: 65px; border-radius: 4px; position: relative; background-color: var(--bg-tertiary); border: 1px solid var(--border-secondary); font-size: 0.7em; overflow: hidden; display: flex; flex-direction: column; justify-content: space-between; padding: 2px; box-shadow: 0 1px 2px var(--shadow-primary); user-select: none; transition: transform 0.2s ease-out, box-shadow 0.2s ease-out, outline 0.2s ease, opacity 0.3s ease; }
.reserved-card-small.interactive:hover { transform: scale(1.05); box-shadow: 0 2px 4px var(--shadow-secondary); outline: 1px solid var(--highlight-interactive); }
.reserved-card-small .card-top-area { padding: 2px 1px 0 2px; height: auto; } .reserved-card-small .card-vp { font-size: 0.9em; } .reserved-card-small .card-gem-bonus { width: 10px; height: 10px; border-width: 1px; box-shadow: none; } .reserved-card-small .card-gem-bonus::before { display: none; } .reserved-card-small .card-center-area { display: none; } .reserved-card-small .card-cost-area { padding: 2px; min-height: auto; background: none; border: none; margin: 0; } .reserved-card-small .cost-item { font-size: 0.7em; padding: 0 1px; font-weight: normal; text-shadow: none; gap: 2px;} .reserved-card-small .cost-dot { width: 6px; height: 6px; margin-right: 1px; }
.reserved-card-small.selected { transform: scale(1.1) !important; outline: 2px solid var(--highlight-selected); outline-offset: 1px; box-shadow: 0 3px 6px var(--shadow-secondary); }
.reserved-card-small.not-affordable { opacity: var(--opacity-affordable); }
.reserved-card-small.card-affordable-now.interactive { outline: 1px solid rgba(245, 197, 66, 0.9); outline-offset: 0px; box-shadow: 0 0 5px rgba(245, 197, 66, 0.4); }
.reserved-card-small.card-affordable-now.interactive:hover { outline-color: rgba(245, 197, 66, 1); box-shadow: 0 0 8px rgba(245, 197, 66, 0.6); }
.player-nobles-display { min-height: 40px; }
.player-nobles-display .noble { box-shadow: 0 1px 3px rgba(0,0,0,0.4); }
.overlay-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--shadow-overlay); display: flex; justify-content: center; align-items: center; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; user-select: none; backdrop-filter: blur(3px); }
.overlay-modal:not(.hidden) { opacity: 1; visibility: visible; }
.modal-content { background-color: var(--bg-modal); padding: 30px; border-radius: 10px; box-shadow: 0 5px 20px var(--shadow-modal); text-align: center; max-width: 500px; width: 90%; color: var(--text-primary); border: 1px solid var(--border-primary); transform: scale(0.95); transition: transform 0.3s ease; }
.overlay-modal:not(.hidden) .modal-content { transform: scale(1); }
.modal-content h2 { margin-top: 0; color: var(--text-heading); }
#return-gems-player-display { display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; margin-bottom: 15px; }
#return-gems-player-display .gem { pointer-events: auto; cursor: pointer; }
#return-gems-player-display .gem.selected { outline: 3px solid var(--highlight-selected-return); transform: scale(1.1);}
#return-gems-selection-display { margin-top: 10px; font-weight: bold; color: var(--text-secondary);}
#noble-choice-overlay .modal-content { max-width: 600px; }
#noble-choice-options { margin-top: 15px; display: flex; justify-content: center; gap: 15px; flex-wrap: wrap;}
#noble-choice-options .noble { pointer-events: auto; cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease; }
#noble-choice-options .noble:hover { transform: scale(1.05); box-shadow: 0 4px 10px var(--shadow-modal); border-color: var(--highlight-active); }
.overlay-modal .modal-content .error-message { margin-top: 15px; }
#game-over-overlay .modal-content { max-width: 950px; max-height: 90vh; overflow-y: auto; text-align: left; background-color: var(--bg-tertiary); border: 1px solid var(--border-secondary); }
#game-over-overlay .modal-content h2 { text-align: center; margin-bottom: 20px; color: var(--text-heading); font-size: 2em; }
#final-scores { margin-top: 0; max-height: none; overflow-y: visible; text-align: left; }
.player-result-entry-detailed { background-color: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: 8px; margin-bottom: 15px; overflow: hidden; transition: background-color 0.3s ease, border-color 0.3s ease; }
.player-result-entry-detailed[open] { background-color: var(--bg-quaternary); }
.player-result-entry-detailed.winner { border-color: var(--highlight-active); box-shadow: 0 0 10px rgba(245, 197, 66, 0.2); }
.player-result-entry-detailed.winner summary { background-color: var(--bg-winner); color: var(--text-vp); }
.player-result-entry-detailed.winner summary .player-rank, .player-result-entry-detailed.winner summary .player-name-endgame, .player-result-entry-detailed.winner summary .player-score-endgame, .player-result-entry-detailed.winner summary .player-summary-stats { color: var(--text-vp); }
.player-result-header-detailed { display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; padding: 12px 18px; cursor: pointer; background-color: var(--bg-player-area); border-bottom: 1px solid var(--border-divider); transition: background-color 0.2s ease; list-style: none; }
.player-result-header-detailed:hover { background-color: var(--bg-quaternary); }
.player-result-header-detailed::-webkit-details-marker { display: none; }
.player-result-header-detailed::before { content: '▶'; font-size: 0.8em; margin-right: 10px; transition: transform 0.2s ease-in-out; display: inline-block; }
.player-result-entry-detailed[open] > .player-result-header-detailed::before { transform: rotate(90deg); }
.player-rank { font-weight: bold; font-size: 1.3em; min-width: 65px; color: var(--text-heading); }
.player-name-endgame { font-size: 1.2em; font-weight: bold; flex-grow: 1; margin: 0 15px; color: var(--text-primary); }
.player-score-endgame { font-size: 1.3em; font-weight: bold; color: var(--text-vp); min-width: 75px; text-align: right; }
.player-summary-stats { font-size: 0.9em; color: var(--text-secondary); margin-left: 20px; font-style: italic; }
.player-result-details-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; padding: 15px 18px; background-color: var(--bg-secondary); }
.stat-column { display: flex; flex-direction: column; gap: 15px; }
.stat-category { background-color: rgba(0,0,0,0.15); padding: 10px 12px; border-radius: 6px; border: 1px solid var(--border-primary); }
.stat-category h4 { margin: 0 0 10px 0; font-size: 1.1em; color: var(--text-secondary); border-bottom: 1px solid var(--border-divider); padding-bottom: 6px; font-family: 'Roboto', sans-serif; font-weight: 700; }
.details-inline { font-size: 0.8em; font-weight: normal; color: var(--text-tertiary); margin-left: 8px; }
.stat-items { display: flex; flex-direction: column; gap: 5px; font-size: 0.95em; color: var(--text-primary); }
.stat-items span { display: block; }
.stat-items.sub-stats { font-size: 0.9em; color: var(--text-secondary); margin-top: 8px; padding-top: 8px; border-top: 1px dashed var(--border-divider); }
.stat-items.flow-stats span { display: flex; align-items: center; gap: 5px; flex-wrap: wrap; }
.stat-items.action-dist-stats span { display: inline-block; margin-right: 15px; }
.cards-summary, .summary-items { display: flex; flex-wrap: wrap; gap: 5px; min-height: 30px; align-items: center; margin-bottom: 5px; }
.no-items { font-style: italic; color: var(--text-tertiary); font-size: 0.9em; margin-left: 5px; }
.tiny-card { width: 35px; height: 50px; border-radius: 4px; position: relative; background: var(--bg-card); border: 2px solid grey; display: flex; flex-direction: column; justify-content: space-between; align-items: center; padding: 2px; box-sizing: border-box; overflow: hidden; flex-shrink: 0; }
.tiny-card-vp { font-size: 0.8em; font-weight: bold; color: var(--text-vp); line-height: 1; margin-top: 1px; }
.tiny-card-gem { width: 18px; height: 18px; border-radius: 50%; margin-bottom: 3px; border: 1px solid rgba(255,255,255,0.1); box-shadow: inset 0 0 2px rgba(0,0,0,0.5); }
.gems-summary.small-gems .gem { width: 22px; height: 22px; font-size: 0.8em; }
.gems-summary.small-gems .gem-count { font-size: 0.65em; min-width: 12px; padding: 1px 3px; bottom: -4px; right: -2px; }
.gem-inline { width: 12px; height: 12px; display: inline-block; border-radius: 50%; text-align: center; font-size: 0.8em; line-height: 12px; color: white; vertical-align: middle; margin: 0 1px; font-weight: bold; border: 1px solid rgba(255,255,255,0.1); }
.nobles-summary .noble { box-shadow: var(--shadow-gem); }
.sub-details { margin-top: 10px; border: 1px solid var(--border-primary); border-radius: 4px; background-color: rgba(0,0,0,0.1); }
.sub-details summary { padding: 5px 8px; cursor: pointer; font-weight: bold; font-size: 0.9em; color: var(--text-secondary); background-color: rgba(255,255,255,0.05); border-radius: 4px; list-style: none; position: relative; }
.sub-details[open] > summary { border-bottom-left-radius: 0; border-bottom-right-radius: 0; border-bottom: 1px solid var(--border-primary); }
.sub-details summary:hover { background-color: rgba(255,255,255,0.08); }
.sub-details summary::-webkit-details-marker { display: none; }
.sub-details summary::before { content: '➕'; font-size: 0.7em; margin-right: 6px; display: inline-block; color: var(--text-tertiary); transition: transform 0.2s ease; }
.sub-details[open] > summary::before { content: '➖'; transform: rotate(180deg); }
.inner-stat-category { padding: 8px 10px; background: none; border: none; }
.inner-stat-category h4 { font-size: 1.0em; margin-bottom: 6px; }
.tie-message { font-weight: bold; margin-top: 20px; text-align: center; font-size: 1.2em; color: var(--text-vp); }
#game-over-overlay .modal-content button#lobby-return-btn { margin-top: 25px; padding: 12px 25px; font-size: 1.1em; display: block; margin-left: auto; margin-right: auto; }

.flex-center { display: flex; justify-content: center; align-items: center; }
.gem-white, .cost-white, .req-white, .player-card-count.gem-white, .tiny-card-gem.gem-white, .cost-dot.gem-white, .gem-inline.gem-white { background-color: #f0f0f0; color: var(--text-white-gem); }
.gem-blue, .cost-blue, .req-blue, .player-card-count.gem-blue, .tiny-card-gem.gem-blue, .cost-dot.gem-blue, .gem-inline.gem-blue { background-color: #3498db; }
.gem-green, .cost-green, .req-green, .player-card-count.gem-green, .tiny-card-gem.gem-green, .cost-dot.gem-green, .gem-inline.gem-green { background-color: #2ecc71; }
.gem-red, .cost-red, .req-red, .player-card-count.gem-red, .tiny-card-gem.gem-red, .cost-dot.gem-red, .gem-inline.gem-red { background-color: #e74c3c; }
.gem-black, .cost-black, .req-black, .player-card-count.gem-black, .tiny-card-gem.gem-black, .cost-dot.gem-black, .gem-inline.gem-black { background-color: #34495e; }
.gem-gold { background: linear-gradient(135deg, #f1c40f, #f39c12); border: 2px solid var(--border-gold-gem); color: #4a3f35; font-weight: 700; }
.player-card-count.gem-white { color: var(--text-white-gem) !important; }
.player-card-count:not(.gem-white) { color: white; }
.cost-gem.gem-white, .req-gem.gem-white { background-color: #f0f0f0; border-color: #bbb;}
.cost-gem.gem-blue, .req-gem.gem-blue { background-color: #3498db; } .cost-gem.gem-green, .req-gem.gem-green { background-color: #2ecc71; } .cost-gem.gem-red, .req-gem.gem-red { background-color: #e74c3c; } .cost-gem.gem-black, .req-gem.gem-black { background-color: #34495e; }
.cost-dot.gem-white { background-color: #f0f0f0; border-color: #bbb; }
.gem-inline.gem-white { border: 1px solid #ccc; }
#gem-bank .gem, #cards-area .card, #cards-area .deck, .reserved-card-small, #pass-turn-btn, #confirm-return-gems-btn, #noble-choice-options .noble { cursor: not-allowed; pointer-events: none; opacity: 0.7; transition: opacity 0.3s ease; }
#cards-area .card.empty-slot, #cards-area .deck.empty { opacity: 0.5; pointer-events: none; cursor: default; }
.interactive { cursor: pointer !important; opacity: 1 !important; pointer-events: auto !important; }
.gem.interactive:hover { transform: scale(1.05); box-shadow: var(--shadow-gem-inner), var(--shadow-gem-hover); outline: 2px solid var(--highlight-interactive); outline-offset: 1px; }
.card.interactive:hover { transform: translateY(-4px) scale(1.02); box-shadow: var(--shadow-card-hover); outline: 2px solid var(--highlight-interactive); outline-offset: 1px; }
.deck.interactive:hover:not(.empty) { background-color: var(--bg-deck-hover); transform: scale(1.02); }
.reserved-card-small.interactive:hover { transform: scale(1.05); box-shadow: 0 2px 4px var(--shadow-secondary); outline: 1px solid var(--highlight-interactive); }
#confirm-return-gems-btn.interactive:not(:disabled), #pass-turn-btn.interactive:not(:disabled) { opacity: 1 !important; cursor: pointer !important; pointer-events: auto !important; }
#pass-turn-btn { background-color: var(--btn-bg-cancel); }
#pass-turn-btn.interactive:hover:not(:disabled) { background-color: var(--btn-bg-cancel-hover); }
#noble-choice-options .noble.interactive:hover { transform: scale(1.05); box-shadow: 0 4px 10px var(--shadow-modal); border-color: var(--highlight-active); }
.preview-selection { outline: 3px dashed var(--highlight-interactive) !important; outline-offset: 2px; transition: outline 0.1s ease-in-out, box-shadow 0.1s ease-in-out; transform: scale(1.05); }
.gem.preview-selection { transform: scale(1.2); }
.gem.preview-return { outline: 3px solid var(--highlight-selected-return) !important; outline-offset: 1px; opacity: 0.9; transform: scale(1.1); transition: outline 0.1s ease-in-out, opacity 0.2s, transform 0.2s; }
@keyframes shake { 0%, 100% { transform: translateX(0); } 10%, 30%, 50%, 70%, 90% { transform: translateX(-3px); } 20%, 40%, 60%, 80% { transform: translateX(3px); } }
```
--- END OF FILE splendor_frontend/style.css ---

--- START OF FILE splendor_frontend/index.html ---
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Splendor Multiplayer</title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&family=Cinzel+Decorative:wght@700&display=swap" rel="stylesheet">
</head>
<body>

    <div id="setup-join-screen" class="active">
        <div class="setup-content">
            <h1 class="setup-title">Splendor</h1>
            <p class="setup-subtitle">Multiplayer Lobby</p>

            <div id="initial-options">
                <div class="setup-option">
                    <label for="player-name-input" class="setup-label">Your Name:</label>
                    <input type="text" id="player-name-input" class="setup-input" placeholder="Enter your name" value="Player">
                </div>
                <div class="action-buttons">
                    <button id="create-game-btn" class="setup-start-button">Create New Game</button>
                    <hr class="divider">
                    <input type="text" id="game-code-input" class="setup-input" placeholder="Enter Game Code">
                    <button id="join-game-btn">Join Game</button>
                </div>
                 <p id="lobby-error" class="error-message"></p>
            </div>

            <div id="create-game-options" class="hidden">
                 <h3>Configure New Game</h3>
                 <div class="setup-option">
                     <label for="player-count-create" class="setup-label">Number of Players:</label>
                     <select id="player-count-create" class="setup-input">
                         <option value="2">2 Players</option>
                         <option value="3">3 Players</option>
                         <option value="4" selected>4 Players</option>
                     </select>
                 </div>
                 <div id="player-configs-area">
                 </div>
                 <div class="setup-option">
                     <label for="simulation-delay-input" class="setup-label">AI Turn Delay (ms, for Simulations):</label>
                     <input type="number" id="simulation-delay-input" value="200" min="0" step="50" class="setup-input">
                     <small>(Delay between AI turns if all players are AI)</small>
                 </div>
                 <button id="confirm-create-game-btn" class="setup-start-button">Confirm & Create</button>
                 <button id="cancel-create-game-btn" class="secondary-button">Cancel</button>
            </div>

            <div id="waiting-lobby" class="hidden">
                 <h2>Waiting Lobby</h2>
                 <p>Game Code: <strong id="display-game-code"></strong> <button id="copy-code-btn" title="Copy Code">📋</button></p>
                 <p id="lobby-status">Waiting for players...</p>
                 <ul id="lobby-player-list"></ul>
                 <button id="start-game-btn" class="setup-start-button hidden">Start Game</button>
                 <p id="connection-status" class="status-message"></p>
            </div>
        </div>
    </div>


    <div id="game-container" class="hidden">
        <div id="game-board">
            <div id="top-bar">
                <div id="nobles-area">
                    <h2>Nobles</h2>
                    <div class="nobles-container"></div>
                </div>
                <div id="timer-area">
                    <h2>Turn Timer</h2>
                    <div id="timer-display">--:--</div>
                </div>
                <div id="game-status">
                    <h2>Game Log</h2>
                    <div id="log-messages"></div>
                     <button id="pass-turn-btn" class="hidden">Pass Turn</button>
                     <span id="server-message" class="status-message"></span>
                </div>
            </div>
            <div id="main-area">
                <div id="bank-area">
                    <h2>Gem Bank</h2>
                    <div id="gem-bank" class="gems-container"></div>
                     <div id="selection-info">
                        <p class="selection-text">Selected Gems: <span id="selected-gems-display">None</span></p>
                        <p class="selection-text">Selected Card: <span id="selected-card-display">None</span></p>
                         <div id="dynamic-action-buttons" style="margin-top: 8px;"></div>
                    </div>
                </div>
                <div id="cards-area">
                    <div class="card-level-row" id="level-3-row">
                        <h3>Level 3</h3>
                        <div class="deck" id="deck-3" title="Level 3 Deck">Deck (<span id="deck-3-count">0</span>)</div>
                        <div class="visible-cards" id="visible-cards-3"></div>
                    </div>
                     <div class="card-level-row" id="level-2-row">
                        <h3>Level 2</h3>
                        <div class="deck" id="deck-2" title="Level 2 Deck">Deck (<span id="deck-2-count">0</span>)</div>
                        <div class="visible-cards" id="visible-cards-2"></div>
                    </div>
                     <div class="card-level-row" id="level-1-row">
                        <h3>Level 1</h3>
                        <div class="deck" id="deck-1" title="Level 1 Deck">Deck (<span id="deck-1-count">0</span>)</div>
                        <div class="visible-cards" id="visible-cards-1"></div>
                    </div>
                </div>
            </div>
            <div id="players-area"></div>
        </div>

        <div id="return-gems-overlay" class="hidden overlay-modal">
            <div class="modal-content">
                <h2>Return Gems</h2>
                <p>You have too many total tokens (<span id="return-gems-count">0</span>/10). Please select <span id="return-gems-needed">0</span> non-gold gems to return.</p>
                <div id="return-gems-player-display" class="gems-container small-gems"></div>
                <div id="return-gems-selection-display">Selected to return: 0/0</div>
                <button id="confirm-return-gems-btn" disabled>Confirm Return</button>
                 <p id="return-gems-error" class="error-message"></p>
            </div>
        </div>
         <div id="game-over-overlay" class="hidden overlay-modal">
            <div class="modal-content">
                <h2>Game Over!</h2>
                <div id="final-scores"></div>
                <button id="lobby-return-btn">Return to Lobby</button>
            </div>
        </div>
        <div id="noble-choice-overlay" class="hidden overlay-modal">
            <div class="modal-content">
                <h2>Choose Your Noble</h2>
                <p>You qualify for multiple nobles. Please select one to visit:</p>
                <div id="noble-choice-options" class="nobles-container"></div>
                 <p id="noble-choice-error" class="error-message"></p>
            </div>
        </div>
    </div>

    <script src="script.js"></script>
</body>
</html>
```
--- END OF FILE splendor_frontend/index.html ---

--- START OF FILE splendor_backend/main.py ---
```python
import logging
import json
from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware

from game.manager import GameManager
from game.models import ( CreateGameRequest, CreateGameResponse, JoinGameResponse, ErrorResponse,
                           WebSocketMessage, PlayerConfigRequest )
from game.exceptions import GameNotFoundError, PlayerNotFoundError, GameLogicError

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

app = FastAPI(title="Splendor Backend")

origins = [
    "http://localhost", "http://localhost:8000",
    "http://127.0.0.1", "http://127.0.0.1:8000",
    "null",
]
app.add_middleware(
    CORSMiddleware, allow_origins=origins, allow_credentials=True,
    allow_methods=["*"], allow_headers=["*"],
)

game_manager = GameManager()

@app.post("/games/create",
          response_model=CreateGameResponse,
          status_code=status.HTTP_201_CREATED,
          summary="Create a new Splendor game with player configurations")
async def create_game_endpoint(request: CreateGameRequest):
    """ Creates game based on detailed player configurations. """
    try:
        game_code, player_id = await game_manager.create_game(request)
        return CreateGameResponse(game_code=game_code, player_id=player_id)
    except ValueError as e: raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    except GameLogicError as e: raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=e.message)
    except Exception as e: logger.exception(f"Unexpected error creating game: {e}"); raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to create game.")

@app.get("/games/join/{game_code}",
         response_model=JoinGameResponse,
         summary="Attempt to join an existing game lobby")
async def join_game_endpoint(game_code: str, player_name: str):
    """ Allows a player to join an existing game lobby before it starts. """
    game_state = game_manager.get_game(game_code)
    if not game_state: raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Game {game_code} not found.")
    if game_state.is_started: raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Game has already started.")

    next_player_id = -1
    for i, player in enumerate(game_state.players):
        if player.type == 'human' and not player.is_connected:
            if i > game_state.creator_player_id and player.name == f"Player {i+1}":
                next_player_id = i
                break
            elif i == game_state.creator_player_id and not player.is_connected:
                 pass

    if next_player_id == -1:
         for i, player in enumerate(game_state.players):
              if player.type == 'human' and not player.is_connected:
                   next_player_id = i
                   break

    if next_player_id == -1:
        if len(game_state.players) >= game_state.game_settings.playerCount:
             raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Game is full.")
        else:
             raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="No available human player slots to join.")

    player = game_state.players[next_player_id]
    player.name = player_name
    logger.info(f"Player '{player_name}' assigned ID {next_player_id} for game {game_code}.")

    state_payload = game_state.model_dump(exclude={'players': {'__all__': {'ws'}}})
    return JoinGameResponse(player_id=next_player_id, game_state=state_payload)

@app.websocket("/ws/{game_code}/{player_id}")
async def websocket_endpoint(websocket: WebSocket, game_code: str, player_id: int):
    """Handles WebSocket connections and game interactions."""
    await game_manager.connect(websocket, game_code, player_id)
    try:
        while True:
            data = await websocket.receive_text()
            try: message_json = json.loads(data); await game_manager.handle_message(game_code, player_id, message_json)
            except json.JSONDecodeError: logger.warning(f"Invalid JSON from P{player_id} game {game_code}: {data}"); await game_manager.send_to_player(game_code, player_id, WebSocketMessage(type="ERROR", payload={"message": "Invalid JSON."}))
            except Exception as e: logger.exception(f"Error processing msg P{player_id} game {game_code}: {e}")
    except WebSocketDisconnect: await game_manager.disconnect(game_code, player_id)
    except Exception as e: logger.exception(f"Unexpected WebSocket error P{player_id} game {game_code}: {e}"); await game_manager.disconnect(game_code, player_id)


if __name__ == "__main__":
    import uvicorn
    logger.info("Starting Splendor Backend Server...")
    uvicorn.run("main:app", host="0.0.0.0", port=8080, reload=True, log_level="info")
```
--- END OF FILE splendor_backend/main.py ---

--- START OF FILE splendor_backend/requirements.txt ---
```
fastapi
uvicorn[standard]
websockets
pydantic
python-dotenv
httpx
```
--- END OF FILE splendor_backend/requirements.txt ---

--- START OF FILE splendor_backend/.env ---
```
# Replace with your actual Gemini API Keys
GEMINI_API_KEY_P0=AIzaSyAl5HGAN3_ssAEfW9b3Kr8ql1cuQkvpQzw
GEMINI_API_KEY_P1=AIzaSyAlSylIFlSxIaWLZkl2nxlL5z_rnxVg5tk
GEMINI_API_KEY_P2=AIzaSyAjDS3rou74GTVZ8nYrIOKW7v7wl2jcaVY
GEMINI_API_KEY_P3=AIzaSyBmhjUvcxpTyfsycCB_U5zmPuwA9LPnLZ0

# Optional: Define available models if needed server-side
# AVAILABLE_AI_MODELS=gemini-1.5-flash,gemini-2.0-flash-lite,gemini-2.0-flash,gemini-2.0-flash-thinking-exp-01-21
```
--- END OF FILE splendor_backend/.env ---

--- START OF FILE splendor_backend/game/__init__.py ---
```python
# This file can be empty
```
--- END OF FILE splendor_backend/game/__init__.py ---

--- START OF FILE splendor_backend/game/models.py ---
```python
from pydantic import BaseModel, Field
from typing import List, Dict, Optional, Any, Literal
from fastapi import WebSocket
from game.data import GEM_TYPES, GOLD

class Cost(BaseModel):
    white: int = 0
    blue: int = 0
    green: int = 0
    red: int = 0
    black: int = 0

class Card(BaseModel):
    id: str
    level: int
    color: str
    vp: int
    cost: Cost

class Noble(BaseModel):
    id: str
    vp: int
    requirements: Cost

class PlayerStats(BaseModel):
    isFirstPlayer: bool = False
    turnsTaken: int = 0
    triggeredGameEnd: bool = False
    turnReached15VP: Optional[int] = None
    cardsPurchasedCount: int = 0
    cardsPurchasedByLevel: Dict[int, int] = Field(default_factory=lambda: {1: 0, 2: 0, 3: 0})
    cardsPurchasedByColor: Dict[str, int] = Field(default_factory=lambda: {gem: 0 for gem in GEM_TYPES})
    purchasedFromReserveCount: int = 0
    purchasedFromBoardCount: int = 0
    selfSufficientPurchases: int = 0
    firstCardPurchasedTurn: Dict[int, Optional[int]] = Field(default_factory=lambda: {1: None, 2: None, 3: None})
    cardsReservedTotalCount: int = 0
    allReservedCardsData: List[Card] = Field(default_factory=list)
    deckReservations: Dict[int, int] = Field(default_factory=lambda: {1: 0, 2: 0, 3: 0})
    boardReservations: Dict[int, int] = Field(default_factory=lambda: {1: 0, 2: 0, 3: 0})
    gemsTaken: Dict[str, int] = Field(default_factory=lambda: {gem: 0 for gem in GEM_TYPES})
    goldTaken: int = 0
    gemsSpent: Dict[str, int] = Field(default_factory=lambda: {gem: 0 for gem in GEM_TYPES})
    goldSpent: int = 0
    gemsReturnedOverLimit: Dict[str, int] = Field(default_factory=lambda: {gem: 0 for gem in GEM_TYPES})
    peakGemsHeld: int = 0
    take3Actions: int = 0
    take2Actions: int = 0
    turnsEndedExactLimit: int = 0
    turnsEndedBelowLimit: int = 0
    noblesAcquiredTurn: Dict[str, int] = Field(default_factory=dict)
    reserveActions: int = 0
    purchaseActions: int = 0
    gemTakeActions: int = 0

class Player(BaseModel):
    id: int
    name: str
    type: Literal['human', 'ai']
    ai_model: Optional[str] = None
    gems: Dict[str, int] = Field(default_factory=lambda: {gem: 0 for gem in GEM_TYPES + [GOLD]})
    cards: List[Card] = Field(default_factory=list)
    reservedCards: List[Card] = Field(default_factory=list)
    nobles: List[Noble] = Field(default_factory=list)
    score: int = 0
    bonuses: Cost = Field(default_factory=Cost)
    stats: PlayerStats = Field(default_factory=PlayerStats)
    ws: Optional[Any] = None
    is_connected: bool = False

    class Config:
        arbitrary_types_allowed = True


class GameSettings(BaseModel):
    playerCount: int
    is_simulation: bool = False
    simulation_delay_ms: int = 200


class GameState(BaseModel):
    game_id: str
    players: List[Player] = Field(default_factory=list)
    bank: Dict[str, int] = Field(default_factory=lambda: {gem: 0 for gem in GEM_TYPES + [GOLD]})
    decks: Dict[int, List[Card]] = Field(default_factory=lambda: {1: [], 2: [], 3: []})
    visible_cards: Dict[int, List[Optional[Card]]] = Field(default_factory=lambda: {1: [None]*4, 2: [None]*4, 3: [None]*4})
    available_nobles: List[Noble] = Field(default_factory=list)
    current_player_index: int = 0
    turn_number: int = 1
    game_settings: GameSettings
    is_game_over_condition_met: bool = False
    game_truly_finished: bool = False
    last_round_player_index: int = -1
    game_history_log: List[Dict] = Field(default_factory=list)
    creator_player_id: int = 0
    is_started: bool = False
    pending_action: Optional[Dict] = None

    class Config:
        arbitrary_types_allowed = True

class PlayerConfigRequest(BaseModel):
    name: str
    type: Literal['human', 'ai']
    ai_model: Optional[str] = None

class CreateGameRequest(BaseModel):
    player_configs: List[PlayerConfigRequest] = Field(..., min_length=2, max_length=4)
    is_simulation: bool = False
    simulation_delay_ms: int = 200


class CreateGameResponse(BaseModel):
    game_code: str
    player_id: int

class JoinGameResponse(BaseModel):
    player_id: int
    game_state: GameState

class ErrorResponse(BaseModel):
    message: str

class WebSocketMessage(BaseModel):
    type: str
    payload: Optional[Dict[str, Any]] = None

class TakeGemsPayload(BaseModel):
    gems: List[str]

class PurchaseCardPayload(BaseModel):
    source: Literal["visible", "reserved"]
    cardId: str

class ReserveCardPayload(BaseModel):
    source: Literal["visible", "deck"]
    cardId: Optional[str] = None
    level: Optional[int] = None

class ReturnGemsPayload(BaseModel):
    gems: List[str]

class ChooseNoblePayload(BaseModel):
    nobleId: str

class StartGamePayload(BaseModel):
    pass

class PassTurnPayload(BaseModel):
    pass
```
--- END OF FILE splendor_backend/game/models.py ---

--- START OF FILE splendor_backend/game/data.py ---
```python
import random

GEM_TYPES = ['white', 'blue', 'green', 'red', 'black']
GOLD = 'gold'

CARDS_DATA = [
    { "level": 1, "color": 'black', "vp": 0, "cost": { "white": 1, "red": 1, "blue": 1, "green": 1 } },
    { "level": 1, "color": 'black', "vp": 0, "cost": { "red": 1, "green": 2 } },
    { "level": 1, "color": 'black', "vp": 0, "cost": { "white": 2, "green": 2 } },
    { "level": 1, "color": 'black', "vp": 0, "cost": { "black": 1, "red": 3, "green": 1 } },
    { "level": 1, "color": 'black', "vp": 0, "cost": { "blue": 3 } },
    { "level": 1, "color": 'black', "vp": 0, "cost": { "white": 1, "red": 1, "blue": 2, "green": 1 } },
    { "level": 1, "color": 'black', "vp": 0, "cost": { "white": 2, "red": 1, "blue": 2 } },
    { "level": 1, "color": 'black', "vp": 1, "cost": { "blue": 4 } },

    { "level": 2, "color": 'black', "vp": 1, "cost": { "white": 3, "blue": 2, "green": 2 } },
    { "level": 2, "color": 'black', "vp": 1, "cost": { "black": 2, "white": 3, "green": 3 } },
    { "level": 2, "color": 'black', "vp": 2, "cost": { "red": 2, "blue": 1, "green": 4 } },
    { "level": 2, "color": 'black', "vp": 2, "cost": { "white": 5 } },
    { "level": 2, "color": 'black', "vp": 2, "cost": { "red": 3, "green": 5 } },
    { "level": 2, "color": 'black', "vp": 3, "cost": { "black": 6 } },

    { "level": 3, "color": 'black', "vp": 3, "cost": { "white": 3, "red": 3, "blue": 3, "green": 5 } },
    { "level": 3, "color": 'black', "vp": 4, "cost": { "red": 7 } },
    { "level": 3, "color": 'black', "vp": 4, "cost": { "black": 3, "red": 6, "green": 3 } },
    { "level": 3, "color": 'black', "vp": 5, "cost": { "black": 3, "red": 7 } },

    { "level": 1, "color": 'blue', "vp": 0, "cost": { "black": 2, "white": 1 } },
    { "level": 1, "color": 'blue', "vp": 0, "cost": { "black": 1, "white": 1, "red": 2, "green": 1 } },
    { "level": 1, "color": 'blue', "vp": 0, "cost": { "black": 1, "white": 1, "red": 1 } },
    { "level": 1, "color": 'blue', "vp": 0, "cost": { "red": 1, "blue": 1, "green": 3 } },
    { "level": 1, "color": 'blue', "vp": 0, "cost": { "black": 3 } },
    { "level": 1, "color": 'blue', "vp": 0, "cost": { "white": 1, "red": 2, "green": 2 } },
    { "level": 1, "color": 'blue', "vp": 0, "cost": { "black": 2, "green": 2 } },
    { "level": 1, "color": 'blue', "vp": 1, "cost": { "red": 4 } },

    { "level": 2, "color": 'blue', "vp": 1, "cost": { "white": 5, "red": 3 } },
    { "level": 2, "color": 'blue', "vp": 1, "cost": { "blue": 2, "red": 3, "green": 2 } },
    { "level": 2, "color": 'blue', "vp": 2, "cost": { "white": 5 } },
    { "level": 2, "color": 'blue', "vp": 2, "cost": { "blue": 5 } },
    { "level": 2, "color": 'blue', "vp": 2, "cost": { "black": 4, "white": 2, "red": 1 } },
    { "level": 2, "color": 'blue', "vp": 3, "cost": { "blue": 6 } },

    { "level": 3, "color": 'blue', "vp": 3, "cost": { "black": 5, "white": 3, "red": 3, "green": 3 } },
    { "level": 3, "color": 'blue', "vp": 4, "cost": { "white": 7 } },
    { "level": 3, "color": 'blue', "vp": 4, "cost": { "black": 3, "white": 6, "blue": 3 } },
    { "level": 3, "color": 'blue', "vp": 5, "cost": { "white": 7, "blue": 3 } },

    { "level": 1, "color": 'green', "vp": 0, "cost": { "white": 2, "blue": 1 } },
    { "level": 1, "color": 'green', "vp": 0, "cost": { "blue": 2, "red": 2 } },
    { "level": 1, "color": 'green', "vp": 0, "cost": { "white": 1, "blue": 3, "red": 1 } },
    { "level": 1, "color": 'green', "vp": 0, "cost": { "black": 1, "white": 1, "blue": 1 } },
    { "level": 1, "color": 'green', "vp": 0, "cost": { "black": 2, "white": 1, "blue": 1 } },
    { "level": 1, "color": 'green', "vp": 0, "cost": { "black": 3, "red": 2 } },
    { "level": 1, "color": 'green', "vp": 0, "cost": { "red": 3 } },
    { "level": 1, "color": 'green', "vp": 1, "cost": { "black": 4 } },

    { "level": 2, "color": 'green', "vp": 1, "cost": { "black": 1, "white": 2, "blue": 4 } },
    { "level": 2, "color": 'green', "vp": 1, "cost": { "white": 3, "blue": 5 } },
    { "level": 2, "color": 'green', "vp": 2, "cost": { "black": 1, "white": 4, "green": 2 } },
    { "level": 2, "color": 'green', "vp": 2, "cost": { "blue": 5 } },
    { "level": 2, "color": 'green', "vp": 2, "cost": { "black": 5, "red": 3 } },
    { "level": 2, "color": 'green', "vp": 3, "cost": { "green": 6 } },

    { "level": 3, "color": 'green', "vp": 3, "cost": { "black": 3, "white": 5, "blue": 3, "red": 3 } },
    { "level": 3, "color": 'green', "vp": 4, "cost": { "blue": 7 } },
    { "level": 3, "color": 'green', "vp": 4, "cost": { "black": 3, "blue": 6, "green": 3 } },
    { "level": 3, "color": 'green', "vp": 5, "cost": { "blue": 7, "green": 3 } },

    { "level": 1, "color": 'red', "vp": 0, "cost": { "black": 3, "white": 3 } },
    { "level": 1, "color": 'red', "vp": 0, "cost": { "black": 1, "white": 1, "blue": 1 } },
    { "level": 1, "color": 'red', "vp": 0, "cost": { "blue": 2, "green": 1 } },
    { "level": 1, "color": 'red', "vp": 0, "cost": { "black": 2, "white": 2, "green": 1 } },
    { "level": 1, "color": 'red', "vp": 0, "cost": { "black": 1, "white": 2, "blue": 1, "green": 1 } },
    { "level": 1, "color": 'red', "vp": 0, "cost": { "black": 1, "white": 1, "green": 1 } },
    { "level": 1, "color": 'red', "vp": 0, "cost": { "white": 2, "blue": 2 } },
    { "level": 1, "color": 'red', "vp": 1, "cost": { "white": 4 } },

    { "level": 2, "color": 'red', "vp": 1, "cost": { "black": 3, "blue": 2, "green": 2 } },
    { "level": 2, "color": 'red', "vp": 1, "cost": { "black": 2, "white": 1, "red": 2 } },
    { "level": 2, "color": 'red', "vp": 2, "cost": { "black": 1, "white": 4, "blue": 2 } },
    { "level": 2, "color": 'red', "vp": 2, "cost": { "black": 5, "white": 3 } },
    { "level": 2, "color": 'red', "vp": 2, "cost": { "black": 5 } },
    { "level": 2, "color": 'red', "vp": 3, "cost": { "red": 6 } },

    { "level": 3, "color": 'red', "vp": 3, "cost": { "black": 3, "white": 3, "blue": 5, "green": 3 } },
    { "level": 3, "color": 'red', "vp": 4, "cost": { "green": 7 } },
    { "level": 3, "color": 'red', "vp": 4, "cost": { "white": 3, "blue": 3, "green": 6 } },
    { "level": 3, "color": 'red', "vp": 5, "cost": { "white": 3, "green": 7 } },

    { "level": 1, "color": 'white', "vp": 0, "cost": { "black": 1, "blue": 2, "green": 2 } },
    { "level": 1, "color": 'white', "vp": 0, "cost": { "black": 1, "red": 2 } },
    { "level": 1, "color": 'white', "vp": 0, "cost": { "black": 1, "red": 1, "blue": 1, "green": 1 } },
    { "level": 1, "color": 'white', "vp": 0, "cost": { "red": 3 } },
    { "level": 1, "color": 'white', "vp": 0, "cost": { "blue": 2, "black": 2 } },
    { "level": 1, "color": 'white', "vp": 0, "cost": { "black": 1, "red": 1, "blue": 1, "green": 2 } },
    { "level": 1, "color": 'white', "vp": 0, "cost": { "black": 1, "white": 3, "blue": 1 } },
    { "level": 1, "color": 'white', "vp": 1, "cost": { "green": 4 } },

    { "level": 2, "color": 'white', "vp": 1, "cost": { "red": 3, "blue": 3, "green": 2 } },
    { "level": 2, "color": 'white', "vp": 1, "cost": { "blue": 5, "green": 3 } },
    { "level": 2, "color": 'white', "vp": 2, "cost": { "black": 2, "green": 1, "red": 4 } },
    { "level": 2, "color": 'white', "vp": 2, "cost": { "red": 5 } },
    { "level": 2, "color": 'white', "vp": 2, "cost": { "black": 3, "red": 5 } },
    { "level": 2, "color": 'white', "vp": 3, "cost": { "white": 6 } },

    { "level": 3, "color": 'white', "vp": 3, "cost": { "black": 3, "red": 3, "blue": 3, "green": 5 } },
    { "level": 3, "color": 'white', "vp": 4, "cost": { "black": 7 } },
    { "level": 3, "color": 'white', "vp": 4, "cost": { "black": 6, "white": 3, "green": 3 } },
    { "level": 3, "color": 'white', "vp": 5, "cost": { "black": 7, "white": 3 } },
]

NOBLES_DATA = [
  { "vp": 3, "requirements": { "black": 3, "red": 3, "white": 3 } },
  { "vp": 3, "requirements": { "blue": 3, "green": 3, "white": 3 } },
  { "vp": 3, "requirements": { "blue": 3, "green": 3, "red": 3 } },
  { "vp": 3, "requirements": { "black": 3, "red": 3, "green": 3 } },
  { "vp": 3, "requirements": { "black": 3, "blue": 3, "white": 3 } },
  { "vp": 3, "requirements": { "black": 4, "red": 4 } },
  { "vp": 3, "requirements": { "green": 4, "red": 4 } },
  { "vp": 3, "requirements": { "blue": 4, "green": 4 } },
  { "vp": 3, "requirements": { "blue": 4, "white": 4 } },
  { "vp": 3, "requirements": { "black": 4, "white": 4 } },
]

_card_id_counter = 0
ALL_CARDS = []
for card_data in CARDS_DATA:
    _card_id_counter += 1
    processed_cost = {gem: card_data["cost"].get(gem, 0) for gem in GEM_TYPES}
    ALL_CARDS.append({
        **card_data,
        "id": f"card-{_card_id_counter}",
        "cost": processed_cost
    })

_noble_id_counter = 0
ALL_NOBLES = []
for noble_data in NOBLES_DATA:
    _noble_id_counter += 1
    processed_reqs = {gem: noble_data["requirements"].get(gem, 0) for gem in GEM_TYPES}
    ALL_NOBLES.append({
        **noble_data,
        "id": f"noble-{_noble_id_counter}",
        "requirements": processed_reqs
    })


def shuffle_deck(cards):
    deck = list(cards)
    random.shuffle(deck)
    return deck
```
--- END OF FILE splendor_backend/game/data.py ---

--- START OF FILE splendor_backend/game/logic.py ---
```python
import random
import copy
import logging
from typing import List, Dict, Optional, Tuple, Any, Literal
import asyncio

from game.models import (
    GameState, Player, Card, Noble, GameSettings, Cost, PlayerStats, PlayerConfigRequest,
    TakeGemsPayload, PurchaseCardPayload, ReserveCardPayload,
    ReturnGemsPayload, ChooseNoblePayload, StartGamePayload, PassTurnPayload
)

from game.data import GEM_TYPES, GOLD, ALL_CARDS, ALL_NOBLES, shuffle_deck
from game.exceptions import (
    InvalidActionError, NotPlayerTurnError, PlayerNotFoundError, GameLogicError
)

logger = logging.getLogger(__name__)

MAX_GEMS_PLAYER = 10
MAX_RESERVED_CARDS = 3
CARDS_PER_LEVEL_VISIBLE = 4
WINNING_SCORE = 15
MIN_GEMS_FOR_TAKE_TWO = 4

def get_player_from_id(game_state: GameState, player_id: int) -> Optional[Player]:
    """Safely get a player object by ID."""
    if 0 <= player_id < len(game_state.players):
        return game_state.players[player_id]
    return None

def get_card_by_id(game_state: GameState, card_id: str) -> Optional[Card]:
    """Find a card by ID in visible or any player's reserved cards."""
    if not card_id: return None
    for level in game_state.visible_cards:
        for card in game_state.visible_cards[level]:
            if card and card.id == card_id: return card
    for player in game_state.players:
        for card in player.reservedCards:
            if card.id == card_id: return card
    return None

def calculate_effective_cost(player: Player, card: Card) -> Tuple[Cost, int]:
    """Calculates the actual gem cost for a player after bonuses, and gold needed."""
    effective_cost_dict = {}
    gold_needed = 0
    for gem_type in GEM_TYPES:
        card_cost = getattr(card.cost, gem_type, 0)
        player_bonus = getattr(player.bonuses, gem_type, 0)
        cost_after_bonus = max(0, card_cost - player_bonus)
        effective_cost_dict[gem_type] = cost_after_bonus
        player_has_gem = player.gems.get(gem_type, 0)
        if player_has_gem < cost_after_bonus: gold_needed += cost_after_bonus - player_has_gem
    effective_cost = Cost(**effective_cost_dict)
    return effective_cost, gold_needed

def can_afford_card(player: Player, card: Card) -> Tuple[bool, int]:
    """Checks if a player can afford a card, returning affordability and gold needed."""
    if not player or not card: return False, 0
    _, gold_needed = calculate_effective_cost(player, card)
    player_has_gold = player.gems.get(GOLD, 0)
    can_afford = player_has_gold >= gold_needed
    return can_afford, gold_needed

def draw_card(game_state: GameState, level: int, index: int):
    """Draws a card from the deck to replace a visible card."""
    if 0 <= index < len(game_state.visible_cards.get(level, [])):
        if game_state.decks[level]: game_state.visible_cards[level][index] = game_state.decks[level].pop()
        else: game_state.visible_cards[level][index] = None
    else: logger.warning(f"Attempted to draw card for invalid index {index} at level {level}")

def log_action(game_state: GameState, player: Player, action_type: str, details: Dict):
    """Adds an entry to the game history log."""
    log_entry = {
        "turn": game_state.turn_number, "playerIndex": player.id, "playerName": player.name,
        "playerType": player.type, "actionType": action_type, "details": copy.deepcopy(details)
    }
    game_state.game_history_log.append(log_entry)
    logger.info(f"[Game {game_state.game_id} Turn {log_entry['turn']}] P{player.id} ({player.name}) {action_type}: {details}")

def initialize_game(game_id: str, settings: GameSettings, player_configs: List[PlayerConfigRequest]) -> GameState:
    """Creates and initializes a new game state based on player configurations."""
    num_players = len(player_configs)
    if not (2 <= num_players <= 4): raise ValueError("Invalid player count (must be 2-4 based on configs).")

    players = []
    for i, config in enumerate(player_configs):
        players.append(Player(
            id=i, name=config.name, type=config.type,
            ai_model=config.ai_model if config.type == 'ai' else None,
            stats=PlayerStats(isFirstPlayer=(i==0))
        ))

    settings.playerCount = num_players
    settings.is_simulation = all(p.type == 'ai' for p in players)

    gem_count = {2: 4, 3: 5, 4: 7}.get(num_players, 7)
    bank = {gem: gem_count for gem in GEM_TYPES}; bank[GOLD] = 5
    all_cards_copy = [Card(**c) for c in copy.deepcopy(ALL_CARDS)]
    decks = { 1: shuffle_deck([c for c in all_cards_copy if c.level == 1]), 2: shuffle_deck([c for c in all_cards_copy if c.level == 2]), 3: shuffle_deck([c for c in all_cards_copy if c.level == 3]), }
    visible_cards: Dict[int, List[Optional[Card]]] = {level: [decks[level].pop() if decks[level] else None for _ in range(CARDS_PER_LEVEL_VISIBLE)] for level in [1, 2, 3]}
    num_nobles = num_players + 1
    all_nobles_copy = [Noble(**n) for n in copy.deepcopy(ALL_NOBLES)]
    available_nobles = random.sample(all_nobles_copy, num_nobles)

    game_state = GameState(
        game_id=game_id, players=players, bank=bank, decks=decks,
        visible_cards=visible_cards, available_nobles=available_nobles,
        game_settings=settings, creator_player_id=0,
    )
    log_action(game_state, players[0], "GAME_CREATE", {"settings": settings.model_dump(), "player_configs": [pc.model_dump() for pc in player_configs]})
    return game_state

def perform_take_gems(game_state: GameState, player_id: int, gems_payload: TakeGemsPayload) -> GameState:
    player = get_player_from_id(game_state, player_id); assert player, f"Player {player_id} not found."
    assert game_state.current_player_index == player_id, f"Not Player {player_id}'s turn."
    assert not game_state.pending_action, "Cannot act during pending action."
    gems_to_take = gems_payload.gems; num_gems = len(gems_to_take); unique_gems = set(gems_to_take)
    assert all(g in GEM_TYPES for g in gems_to_take), "Invalid gem type."
    if num_gems == 3: assert len(unique_gems) == 3, "Must take 3 different."; assert all(game_state.bank.get(g, 0) >= 1 for g in gems_to_take), "Bank lacks gems for take 3."; player.stats.take3Actions += 1
    elif num_gems == 2: assert len(unique_gems) == 1, "Must take 2 identical."; gem_type = gems_to_take[0]; assert game_state.bank.get(gem_type, 0) >= MIN_GEMS_FOR_TAKE_TWO, f"Bank needs {MIN_GEMS_FOR_TAKE_TWO} {gem_type} to take two."; player.stats.take2Actions += 1
    else: raise InvalidActionError("Must take 2 or 3 gems.")
    gems_taken_log = {}
    for gem_type in gems_to_take: game_state.bank[gem_type] -= 1; player.gems[gem_type] = player.gems.get(gem_type, 0) + 1; gems_taken_log[gem_type] = gems_taken_log.get(gem_type, 0) + 1; player.stats.gemsTaken[gem_type] = player.stats.gemsTaken.get(gem_type, 0) + 1
    player.stats.gemTakeActions += 1
    log_action(game_state, player, "TAKE_GEMS", {"gems": gems_to_take})
    return end_turn_sequence(game_state, player)

def perform_reserve_card(game_state: GameState, player_id: int, reserve_payload: ReserveCardPayload) -> GameState:
    player = get_player_from_id(game_state, player_id); assert player, f"Player {player_id} not found."
    assert game_state.current_player_index == player_id, f"Not Player {player_id}'s turn."
    assert not game_state.pending_action, "Cannot act during pending action."
    assert len(player.reservedCards) < MAX_RESERVED_CARDS, "Reservation limit reached."
    source = reserve_payload.source; reserved_card_data: Optional[Card] = None; level_reserved = -1; card_replaced = False
    if source == "deck":
        level = reserve_payload.level; assert level in [1, 2, 3], "Invalid deck level."; assert game_state.decks[level], f"Deck L{level} empty."; level_reserved = level; reserved_card_data = game_state.decks[level].pop(); player.stats.deckReservations[level] += 1
    elif source == "visible":
        card_id = reserve_payload.cardId; assert card_id, "Card ID required."; found_card_info = next(((lvl, idx, card) for lvl, cards in game_state.visible_cards.items() for idx, card in enumerate(cards) if card and card.id == card_id), None); assert found_card_info, f"Visible card {card_id} not found."
        level, index, reserved_card_data = found_card_info; level_reserved = level; player.stats.boardReservations[level] += 1; draw_card(game_state, level, index); card_replaced = True
    else: raise InvalidActionError(f"Invalid reserve source: {source}")
    player.reservedCards.append(reserved_card_data); player.stats.reserveActions += 1; player.stats.cardsReservedTotalCount += 1; player.stats.allReservedCardsData.append(reserved_card_data.model_copy(deep=True))
    got_gold = False
    if game_state.bank[GOLD] > 0: player.gems[GOLD] += 1; game_state.bank[GOLD] -= 1; got_gold = True; player.stats.goldTaken += 1
    log_action(game_state, player, "RESERVE_CARD", {"cardId": reserved_card_data.id, "source": source, "level": level_reserved, "color": reserved_card_data.color, "gotGold": got_gold})
    return end_turn_sequence(game_state, player)

def perform_purchase_card(game_state: GameState, player_id: int, purchase_payload: PurchaseCardPayload) -> GameState:
    player = get_player_from_id(game_state, player_id); assert player, f"Player {player_id} not found."
    assert game_state.current_player_index == player_id, f"Not Player {player_id}'s turn."
    assert not game_state.pending_action, "Cannot act during pending action."
    source = purchase_payload.source; card_id = purchase_payload.cardId; purchased_card_data: Optional[Card] = None; card_index = -1; is_from_reserve = (source == "reserved"); card_replaced = False
    if source == "visible": found_card_info = next(((lvl, idx, card) for lvl, cards in game_state.visible_cards.items() for idx, card in enumerate(cards) if card and card.id == card_id), None); assert found_card_info, f"Visible card {card_id} not found."; level, card_index, purchased_card_data = found_card_info
    elif source == "reserved": found_card_info = next(((idx, card) for idx, card in enumerate(player.reservedCards) if card.id == card_id), None); assert found_card_info, f"Reserved card {card_id} not found."; card_index, purchased_card_data = found_card_info
    else: raise InvalidActionError(f"Invalid purchase source: {source}")
    can_afford, gold_needed = can_afford_card(player, purchased_card_data); assert can_afford, f"Cannot afford card {card_id}. Need {gold_needed} more gold."
    effective_cost, _ = calculate_effective_cost(player, purchased_card_data); gold_spent_this_turn = 0; gems_spent_this_turn = {gem: 0 for gem in GEM_TYPES}; total_resource_cost = 0
    for gem_type in GEM_TYPES:
        cost_to_pay = getattr(effective_cost, gem_type, 0); player_has = player.gems.get(gem_type, 0); use_from_player_gems = min(cost_to_pay, player_has); needs_gold = cost_to_pay - use_from_player_gems
        if use_from_player_gems > 0: player.gems[gem_type] -= use_from_player_gems; game_state.bank[gem_type] += use_from_player_gems; gems_spent_this_turn[gem_type] += use_from_player_gems; total_resource_cost += use_from_player_gems
        if needs_gold > 0: player.gems[GOLD] -= needs_gold; game_state.bank[GOLD] += needs_gold; gold_spent_this_turn += needs_gold; total_resource_cost += needs_gold
    player.cards.append(purchased_card_data); player.score += purchased_card_data.vp; setattr(player.bonuses, purchased_card_data.color, getattr(player.bonuses, purchased_card_data.color) + 1)
    player.stats.purchaseActions += 1; player.stats.cardsPurchasedCount += 1; lvl = purchased_card_data.level; player.stats.cardsPurchasedByLevel[lvl] += 1; clr = purchased_card_data.color; player.stats.cardsPurchasedByColor[clr] += 1
    if is_from_reserve: player.stats.purchasedFromReserveCount += 1
    else: player.stats.purchasedFromBoardCount += 1
    if total_resource_cost == 0: player.stats.selfSufficientPurchases += 1
    player.stats.goldSpent += gold_spent_this_turn
    for type, spent in gems_spent_this_turn.items(): player.stats.gemsSpent[type] += spent
    if player.stats.firstCardPurchasedTurn.get(lvl) is None: player.stats.firstCardPurchasedTurn[lvl] = game_state.turn_number
    if source == "visible": draw_card(game_state, purchased_card_data.level, card_index); card_replaced = True
    else: player.reservedCards.pop(card_index)
    log_action(game_state, player, "PURCHASE_CARD", {"cardId": purchased_card_data.id, "source": source, "level": purchased_card_data.level, "color": purchased_card_data.color, "vp": purchased_card_data.vp, "costPaid": gems_spent_this_turn, "goldUsed": gold_spent_this_turn})
    return end_turn_sequence(game_state, player)

def perform_return_gems(game_state: GameState, player_id: int, return_payload: ReturnGemsPayload) -> GameState:
    player = get_player_from_id(game_state, player_id); assert player, f"Player {player_id} not found."
    assert game_state.pending_action and game_state.pending_action.get("type") == "RETURN_GEMS" and game_state.pending_action.get("player_id") == player_id, "Not expecting gem return."
    gems_to_return = return_payload.gems; count_needed = game_state.pending_action.get("count_needed", 0)
    assert len(gems_to_return) == count_needed, f"Must return {count_needed} gems."; assert all(g in GEM_TYPES for g in gems_to_return), "Cannot return gold."
    temp_gems = player.gems.copy(); returned_counts = {}
    for gem_type in gems_to_return: assert temp_gems.get(gem_type, 0) > 0, f"Player lacks {gem_type} to return."; temp_gems[gem_type] -= 1; returned_counts[gem_type] = returned_counts.get(gem_type, 0) + 1
    for gem_type, count in returned_counts.items(): player.gems[gem_type] -= count; game_state.bank[gem_type] += count; player.stats.gemsReturnedOverLimit[gem_type] += count
    log_action(game_state, player, "RETURN_GEMS", {"returnedGems": returned_counts}); game_state.pending_action = None
    return check_nobles_and_advance(game_state, player)

def perform_choose_noble(game_state: GameState, player_id: int, choice_payload: ChooseNoblePayload) -> GameState:
    player = get_player_from_id(game_state, player_id); assert player, f"Player {player_id} not found."
    assert game_state.pending_action and game_state.pending_action.get("type") == "CHOOSE_NOBLE" and game_state.pending_action.get("player_id") == player_id, "Not expecting noble choice."
    chosen_noble_id = choice_payload.nobleId; eligible_nobles_data = game_state.pending_action.get("eligible_nobles", []); eligible_nobles : List[Noble] = [Noble(**data) for data in eligible_nobles_data]
    chosen_noble = next((n for n in eligible_nobles if n.id == chosen_noble_id), None); assert chosen_noble, f"Chosen noble {chosen_noble_id} not eligible."
    awarded = award_noble_if_eligible(game_state, player, chosen_noble)
    if not awarded: logger.warning(f"Failed to award chosen noble {chosen_noble_id} to P{player_id}.")
    game_state.pending_action = None
    return check_gem_limit_and_advance(game_state, player)

def perform_pass_turn(game_state: GameState, player_id: int) -> GameState:
    player = get_player_from_id(game_state, player_id); assert player, f"Player {player_id} not found."
    assert game_state.current_player_index == player_id, f"Not Player {player_id}'s turn."
    assert not game_state.pending_action, "Cannot pass during pending action."
    log_action(game_state, player, "PASS_TURN", {})
    return advance_turn(game_state)

def end_turn_sequence(game_state: GameState, player: Player) -> GameState:
    player.stats.turnsTaken += 1; current_total_gems = sum(player.gems.values()); player.stats.peakGemsHeld = max(player.stats.peakGemsHeld, current_total_gems)
    if current_total_gems == MAX_GEMS_PLAYER: player.stats.turnsEndedExactLimit += 1
    elif current_total_gems < MAX_GEMS_PLAYER: player.stats.turnsEndedBelowLimit += 1
    return check_nobles_and_advance(game_state, player)

def check_nobles_and_advance(game_state: GameState, player: Player) -> GameState:
    eligible_nobles = [n for n in game_state.available_nobles if all(getattr(player.bonuses, gem, 0) >= getattr(n.requirements, gem, 0) for gem in GEM_TYPES)] if game_state.available_nobles else []
    if len(eligible_nobles) == 1: award_noble_if_eligible(game_state, player, eligible_nobles[0]); return check_gem_limit_and_advance(game_state, player)
    elif len(eligible_nobles) > 1: game_state.pending_action = {"type": "CHOOSE_NOBLE", "player_id": player.id, "eligible_nobles": [n.model_dump() for n in eligible_nobles]}; log_action(game_state, player, "PENDING_NOBLE_CHOICE", {"count": len(eligible_nobles)}); return game_state
    else: return check_gem_limit_and_advance(game_state, player)

def award_noble_if_eligible(game_state: GameState, player: Player, noble: Noble) -> bool:
    noble_in_list = next((n for n in game_state.available_nobles if n.id == noble.id), None)
    if noble_in_list:
        if not all(getattr(player.bonuses, gem, 0) >= getattr(noble_in_list.requirements, gem, 0) for gem in GEM_TYPES): logger.warning(f"Attempted award noble {noble.id} to P{player.id}, reqs no longer met."); return False
        game_state.available_nobles.remove(noble_in_list); player.nobles.append(noble_in_list); player.score += noble_in_list.vp; player.stats.noblesAcquiredTurn[noble.id] = game_state.turn_number
        log_action(game_state, player, "NOBLE_VISIT", {"nobleId": noble.id, "vp": noble.vp}); return True
    else: logger.warning(f"Attempted award noble {noble.id} no longer available."); return False

def check_gem_limit_and_advance(game_state: GameState, player: Player) -> GameState:
    non_gold_gems = sum(player.gems.get(gem, 0) for gem in GEM_TYPES); total_gems = non_gold_gems + player.gems.get(GOLD, 0)
    if total_gems > MAX_GEMS_PLAYER:
        excess_gems = total_gems - MAX_GEMS_PLAYER; gems_to_return_count = min(excess_gems, non_gold_gems)
        if gems_to_return_count > 0: game_state.pending_action = {"type": "RETURN_GEMS", "player_id": player.id, "count_needed": gems_to_return_count, "current_total": total_gems, "non_gold_owned": {g: player.gems.get(g,0) for g in GEM_TYPES if player.gems.get(g,0)>0}}; log_action(game_state, player, "PENDING_GEM_RETURN", {"count": gems_to_return_count}); return game_state
        else: log_action(game_state, player, "OVER_GEM_LIMIT_CANT_RETURN", {"total": total_gems}); return advance_turn(game_state)
    else: return advance_turn(game_state)

def advance_turn(game_state: GameState) -> GameState:
    current_player = get_player_from_id(game_state, game_state.current_player_index); assert current_player, "Current player not found."
    score_reached = current_player.score >= WINNING_SCORE
    if score_reached and current_player.stats.turnReached15VP is None: current_player.stats.turnReached15VP = game_state.turn_number
    game_end_triggered = False
    if not game_state.is_game_over_condition_met and score_reached:
        game_state.is_game_over_condition_met = True; game_state.last_round_player_index = (game_state.current_player_index - 1 + len(game_state.players)) % len(game_state.players); game_end_triggered = True; current_player.stats.triggeredGameEnd = True
        log_action(game_state, current_player, "GAME_END_TRIGGERED", {"score": current_player.score}); logger.info(f"--- Game end trigger P{current_player.id}. Final round ends after P{game_state.last_round_player_index}. ---")
    if game_state.is_game_over_condition_met and game_state.current_player_index == game_state.last_round_player_index:
        game_state.game_truly_finished = True; log_action(game_state, current_player, "FINAL_TURN_COMPLETED", {}); logger.info(f"--- GAME OVER (P{current_player.id} completed final turn) ---"); return game_state
    game_state.current_player_index = (game_state.current_player_index + 1) % len(game_state.players)
    if game_state.current_player_index == 0:
        if not game_state.is_game_over_condition_met or game_end_triggered: game_state.turn_number += 1; logger.info(f"--- Starting Turn {game_state.turn_number} ---")
    next_player = get_player_from_id(game_state, game_state.current_player_index); assert next_player
    log_action(game_state, next_player, "TURN_START", {"turn": game_state.turn_number}); logger.info(f"--- Player {next_player.id}'s turn ({next_player.name}) ---")
    return game_state

def execute_ai_turn(game_state: GameState, player_id: int) -> GameState:
    from game.ai_service import get_ai_action
    player = get_player_from_id(game_state, player_id); assert player and player.type == 'ai', "Invalid AI player."
    logger.info(f"Executing SYNC AI turn logic for P{player_id} ({player.name})")
    chosen_action = None
    if chosen_action:
        action_type = chosen_action.get("action")
        try: logger.info(f"AI P{player_id} SYNC executing: {action_type}");
        except Exception as e: logger.exception(f"Error SYNC AI action {chosen_action}. Falling back. Error: {e}"); return execute_fallback_ai_action(game_state, player)
    else: logger.warning(f"AI (P{player_id}) SYNC failed action. Falling back."); return execute_fallback_ai_action(game_state, player)

def execute_fallback_ai_action(game_state: GameState, player: Player) -> GameState:
    """Determines and executes a simple fallback action for the AI."""
    logger.warning(f"Executing FALLBACK AI action for P{player.id} ({player.name})");
    player_id = player.id

    cheapest_card_info = None
    min_cost = float('inf')
    possible_purchases = []

    for level in game_state.visible_cards:
        for card in game_state.visible_cards[level]:
            if card:
                possible_purchases.append({"card": card, "source": "visible"})
    for card in player.reservedCards:
         if card:
            possible_purchases.append({"card": card, "source": "reserved"})

    for item in possible_purchases:
        card = item["card"]
        source = item["source"]
        if card:
            can_afford, _ = can_afford_card(player, card)
            if can_afford:
                effective_cost, _ = calculate_effective_cost(player, card)
                total_cost = sum(getattr(effective_cost, gem, 0) for gem in GEM_TYPES)
                cost_metric = total_cost - (card.vp * 0.1)
                if cost_metric < min_cost:
                    min_cost = cost_metric
                    cheapest_card_info = {"cardId": card.id, "source": source}

    if cheapest_card_info:
        log_action(game_state, player, "FALLBACK_PURCHASE", cheapest_card_info)
        try:
            return perform_purchase_card(game_state, player_id, PurchaseCardPayload(**cheapest_card_info))
        except Exception as e:
            logger.error(f"Fallback purchase failed: {e}. Trying next fallback.")

    available_single_gems = [g for g in GEM_TYPES if game_state.bank.get(g, 0) >= 1]
    if len(available_single_gems) >= 3:
        gems_to_take = random.sample(available_single_gems, 3)
        payload = TakeGemsPayload(gems=gems_to_take)
        log_action(game_state, player, "FALLBACK_TAKE_3", {"gems": gems_to_take})
        try:
            return perform_take_gems(game_state, player_id, payload)
        except Exception as e:
            logger.error(f"Fallback take 3 failed: {e}. Trying next fallback.")

    take_two_type = next((g for g in GEM_TYPES if game_state.bank.get(g, 0) >= MIN_GEMS_FOR_TAKE_TWO), None)
    if take_two_type:
        payload = TakeGemsPayload(gems=[take_two_type, take_two_type])
        log_action(game_state, player, "FALLBACK_TAKE_2", {"gems": [take_two_type, take_two_type]})
        try:
            return perform_take_gems(game_state, player_id, payload)
        except Exception as e:
             logger.error(f"Fallback take 2 failed: {e}. Trying next fallback.")

    if len(player.reservedCards) < MAX_RESERVED_CARDS:
        visible_l1 = next((c for c in game_state.visible_cards.get(1, []) if c), None)
        if visible_l1:
            payload = ReserveCardPayload(source="visible", cardId=visible_l1.id)
            log_action(game_state, player, "FALLBACK_RESERVE_VISIBLE", {"cardId": visible_l1.id})
            try:
                return perform_reserve_card(game_state, player_id, payload)
            except Exception as e:
                logger.error(f"Fallback reserve visible failed: {e}. Trying next fallback.")
        elif game_state.decks.get(1) and len(game_state.decks[1]) > 0:
            payload = ReserveCardPayload(source="deck", level=1)
            log_action(game_state, player, "FALLBACK_RESERVE_DECK", {"level": 1})
            try:
                return perform_reserve_card(game_state, player_id, payload)
            except Exception as e:
                 logger.error(f"Fallback reserve deck failed: {e}. Trying next fallback.")

    log_action(game_state, player, "FALLBACK_PASS", {})
    logger.warning(f"AI (P{player.id}) passing turn as fallback.")
    return advance_turn(game_state)

def execute_fallback_return_gems(game_state: GameState, player: Player, count_needed: int) -> GameState:
    logger.warning(f"Executing FALLBACK AI return gems for P{player.id} ({player.name}), needs {count_needed}"); available_to_return = []; [available_to_return.extend([gem_type] * player.gems.get(gem_type, 0)) for gem_type in GEM_TYPES]
    if not available_to_return: logger.error(f"Fallback return failed P{player.id}: no non-gold gems."); game_state.pending_action = None; return advance_turn(game_state)
    gem_counts = {gem: available_to_return.count(gem) for gem in set(available_to_return)}; available_to_return.sort(key=lambda gem: gem_counts[gem], reverse=True); gems_to_return = available_to_return[:count_needed]
    if len(gems_to_return) < count_needed: logger.error(f"Fallback return failed P{player.id}: Couldn't select {count_needed}."); game_state.pending_action = None; return advance_turn(game_state)
    payload = ReturnGemsPayload(gems=gems_to_return)
    try:
        if not game_state.pending_action or game_state.pending_action.get("type") != "RETURN_GEMS": logger.warning("Setting pending action state for fallback return gems."); game_state.pending_action = {"type": "RETURN_GEMS", "player_id": player.id, "count_needed": count_needed}
        return perform_return_gems(game_state, player.id, payload)
    except Exception as e: logger.exception(f"Fallback return gems execution failed: {e}"); game_state.pending_action = None; return advance_turn(game_state)

def execute_fallback_noble_choice(game_state: GameState, player: Player, eligible_nobles: List[Noble]) -> GameState:
    logger.warning(f"Executing FALLBACK AI noble choice for P{player.id} ({player.name})")
    if not eligible_nobles: logger.error("Fallback noble choice called with no eligible nobles."); game_state.pending_action = None; return check_gem_limit_and_advance(game_state, player)
    eligible_nobles.sort(key=lambda n: n.vp, reverse=True); chosen_noble = eligible_nobles[0]; payload = ChooseNoblePayload(nobleId=chosen_noble.id)
    try:
        if not game_state.pending_action or game_state.pending_action.get("type") != "CHOOSE_NOBLE": logger.warning("Setting pending action state for fallback noble choice."); game_state.pending_action = {"type": "CHOOSE_NOBLE", "player_id": player.id, "eligible_nobles": [n.model_dump() for n in eligible_nobles] }
        return perform_choose_noble(game_state, player.id, payload)
    except Exception as e: logger.exception(f"Fallback noble choice execution failed: {e}"); game_state.pending_action = None; return check_gem_limit_and_advance(game_state, player)


def calculate_winner(game_state: GameState) -> List[Player]:
    if not game_state.game_truly_finished: return []
    sorted_players = sorted(game_state.players, key=lambda p: (p.score, -p.stats.cardsPurchasedCount), reverse=True)
    if not sorted_players: return []
    top_score = sorted_players[0].score; potential_winners = [p for p in sorted_players if p.score == top_score]
    min_cards = min(p.stats.cardsPurchasedCount for p in potential_winners); winners = [p for p in potential_winners if p.stats.cardsPurchasedCount == min_cards]
    if winners: log_action(game_state, winners[0], "GAME_WINNER_CALCULATED", {"winners": [p.id for p in winners], "scores": {p.id: p.score for p in sorted_players}, "cards": {p.id: p.stats.cardsPurchasedCount for p in sorted_players}})
    return winners
```
--- END OF FILE splendor_backend/game/logic.py ---

--- START OF FILE splendor_backend/game/manager.py ---
```python
import random
import string